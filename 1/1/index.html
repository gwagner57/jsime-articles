<!DOCTYPE html>

<html prefix="og: http://ogp.me/ns#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
    <meta content="IE=edge" http-equiv="X-UA-Compatible"/>
    <title>JSimE 1/1 - Information and Process Modeling for Simulation – Part I</title>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <!--Google Scholar-->
    <meta name="citation_publisher" content="Consortium for True Open Access in Modeling and Simulation" />
    <meta name="citation_journal_title" content="Journal of Simulation Engineering" />
    <meta name="citation_journal_abbrev" content="JSimE" />
    <meta name="citation_issn" content="2569-9466" />
    <meta name="citation_volume" content="1" />
    <meta name="citation_doi" content="10.5281/zenodo.11110129" />
    <meta name="citation_firstpage" content="1:1" />
    <meta name="citation_lastpage" content="1:26" />
    <meta name="citation_title" content="Information and Process Modeling for Simulation – Part I" />
    <meta name="citation_article_type" content="Tutorial" />
    <meta name="citation_online_date" content="2017/10/5" />
    <meta name="citation_publication_date" content="2018/6/28" />
    <meta name="citation_author" content="Gerd Wagner" />
    <meta name="citation_author_email" content="G.Wagner@b-tu.de" />
    <meta name="citation_author_institution" content="Dept. of Informatics, Brandenburg University of Technology, Cottbus, Germany" />
    <meta name="citation_abstract_html_url" content="https://articles.jsime.org/1/1/Modeling-for-Simulation-Part-I" />
    <meta name="citation_pdf_url" content="https://articles.jsime.org/1/jsime-article-1-1.pdf" />
    <meta name="citation_fulltext_html_url" content="https://articles.jsime.org/1/1/Modeling-for-Simulation-Part-I" />
    <!--Open Graph-->
    <meta property="og:type" content="article" />
    <meta property="article:author" content="Gerd Wagner" />
    <meta property="article:section" content="Tutorial" />
    <meta property="article:tag" content="Conceptual Model" />
    <meta property="article:tag" content="Design Model" />
    <meta property="article:tag" content="Information Model" />
    <meta property="article:tag" content="Process Model" />
    <meta property="article:published_time" content="2018-06-28" />
    <meta property="article:modified_time" content="2024-05-12" />
    <meta property="og:title" content="Information and Process Modeling for Simulation – Part I" />
    <meta property="og:description" content="In simulation engineering, a system model mainly consists of an information model and a process model. In the fields of Information Systems and Software Engineering (IS/SE) there are widely used standards such as the Class Diagrams of the Unified Modeling Language (UML) for making information models, and the Business Process Modeling Notation (BPMN) for making process models. This tutorial presents a general approach how to use UML class diagrams and BPMN process diagrams at all three levels of model-driven simulation engineering: for making conceptual domain models, for making platform-independent simulation design models, and for making platform-specific, executable simulation models. In our Object-Event Modeling (OEM) approach, object and event types are modeled as stereotyped classes, random variables are modeled as stereotyped operations constrained to comply with a specific probability distribution, and queues are modeled as ordered association ends, while event rules/routines are modeled both as BPMN process diagrams and in pseudo-code. In Part II, we discuss the more advanced modeling concepts of activities and GPSS/SIMAN/Arena-style processing networks, while in Part III we further extend the OEM framework by adding the concepts of agents with perceptions, actions and beliefs." />
    <meta property="og:url" content="https://articles.jsime.org/1/1/Modeling-for-Simulation-Part-I" />
    <meta property="og:image" content="https://articles.jsime.org/JSimE.svg" />
    <meta property="og:image:type" content="image/svg+xml" />
    <meta property="og:image:alt" content="JSimE" />
    <meta property="og:site_name" content="Journal of Simulation Engineering" />
    <!--Twitter-->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:title" content="Information and Process Modeling for Simulation – Part I" />
    <!--Canonical URL-->
    <link href="https://articles.jsime.org/1/1/Modeling-for-Simulation-Part-I" rel="canonical"/>
    <!--Stylesheets-->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" rel="stylesheet"/>
    <!-- load asynchronously using a trick -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.20.0/themes/prism.min.css" rel="stylesheet" media="all" onload="if(this.media!='all')this.media='all'"/>
    <link href="../../css/jsime.css" rel="stylesheet">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script async="async" src="https://www.google-analytics.com/analytics.js" type="text/javascript"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-115543812-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag () {
        dataLayer.push( arguments );
      }
      gtag( 'js', new Date() );
      gtag( 'config', 'UA-115543812-1', {
        'anonymize_ip': true
      } );
    </script>
    <!--Scripts-->
    <script defer src="../../js/jsime.js"></script>
    <!--schema.org JSON-LD-->
    <script type="application/ld+json">
      {
        "@context": {
          "@vocab": "http://schema.org",
          "@base": "https://articles.jsime.org"
        },
        "@graph": [
          {
            "@type": "ScholarlyArticle",
            "name": "Information and Process Modeling for Simulation – Part I: Objects and Events",
            "author": [
              { "@id": "/1/1/author-1" }
            ],
            "keywords": [ "Conceptual Model", "Design Model", "Information Model", "Process Model" ],
            "description": "In simulation engineering, a system model mainly consists of an information model and a process model. In the fields of Information Systems and Software Engineering (IS/SE) there are widely used standards such as the Class Diagrams of the Unified Modeling Language (UML) for making information models, and the Business Process Modeling Notation (BPMN) for making process models. This tutorial presents a general approach how to use UML class diagrams and BPMN process diagrams at all three levels of model-driven simulation engineering: for making conceptual domain models, for making platform-independent simulation design models, and for making platform-specific, executable simulation models. In our Object-Event Modeling (OEM) approach, object and event types are modeled as stereotyped classes, random variables are modeled as stereotyped operations constrained to comply with a specific probability distribution, and queues are modeled as ordered association ends, while event rules/routines are modeled both as BPMN process diagrams and in pseudo-code. In Part II, we discuss the more advanced modeling concepts of activities and GPSS/SIMAN/Arena-style processing networks, while in Part III we further extend the OEM framework by adding the concepts of agents with perceptions, actions and beliefs.",
            "url": "https://articles.jsime.org/1/1/Modeling-for-Simulation-Part-I",
            "sameAs": "https://doi.org/10.5281/zenodo.11110129",
            "inLanguage": "en-US",
            "license": "https://creativecommons.org/licenses/by/4.0/",
            "copyrightHolder": [
              { "@id": "/1/1/author-1" }
            ],
            "copyrightYear": "2018",
            "dateCreated": "2017-10-05",
            "dateModified": "2024-05-12",
            "datePublished": "2018-06-28",
            "isPartOf": {
              "@type": "PublicationVolume",
              "datePublished": "2018-06-28",
              "volumeNumber": "1",
              "url": "https://articles.jsime.org/1/",
              "isPartOf": {
                "@type": "Periodical",
                "name": "Journal of Simulation Engineering",
                "issn": "2569-9466",
                "url": "https://jsime.org",
                "publisher": {
                  "@type": "Organization",
                  "name": "Consortium for True Open Access in Modeling and Simulation",
                  "url": "https://articles.jsime.org/consortium-for-true-open-access"
                },
                "publishingPrinciples": "http://publicationethics.org/files/Code_of_conduct_for_journal_editors.pdf"
              }
            },
            "about": [
              {
                "@type": "CategoryCode",
                "identifier": "10010147.10010341.10010342.10010343",
                "codeValue": "Computing methodologies~Modeling methodologies",
                "inCodeSet": "http://totem.semedica.com/taxonomy/The%20ACM%20Computing%20Classification%20System%20(CCS)"
              }
            ]
          },
          {
            "@id": "/1/1/author-1",
            "@type": "Person",
            "name": "Gerd Wagner",
            "email": "G.Wagner@b-tu.de",
            "affiliation": [
              { "@id": "/1/1/affiliation-1" }
            ]
          },
          {
            "@id": "/1/1/affiliation-1",
            "@type": "Organization",
            "name": "Brandenburg University of Technology",
            "department": "Department of Informatics",
            "address": {
              "addressLocality": "Cottbus",
              "addressCountry": "Germany"
            }
          }
        ]
      }
    </script>
  </head>

  <body vocab="http://schema.org/">
   <header>
    <a href="https://jsime.org"><img src="../../img/JSimE.svg" style="height: 24px; margin-right: 0.7em;"></a>
	<i>Journal of Simulation Engineering</i>, Volume 1 (2018/2019). Article URL: <a href="https://articles.jsime.org/1/1/Modeling-for-Simulation-Part-I" id="articleURL">https://articles.jsime.org/1/1</a> <a class="suppressInPDF" href="https://articles.jsime.org/1/jsime-article-1-1.pdf" id="PDF" style="position: relative; left: 1em"> <img src="../../icons/pdf.png"></a> </header>
  <main>
      <div id="front-matter">
        <div id="article-number">1</div>

        <h1 id="article-title">Information and Process Modeling for Simulation – Part I: Objects and Events</h1>

        <div id="article-title-abbr">Information and Process Modeling for Simulation – Part I</div>

        <address typeof="Person">
          <div property="name">Gerd Wagner</div>

          <div property="email">
            <a href="mailto:G.Wagner@b-tu.de">G.Wagner@b-tu.de</a>
          </div>

          <div property="affiliation">Dept. of Informatics, Brandenburg University of Technology, Cottbus, Germany</div>
        </address>

        <div id="acm-subject-categories">
          <h1>ACM Subject Categories</h1>

          <ul>
            <li>
              <code>Computing methodologies~Modeling methodologies</code>
            </li>
          </ul>
        </div>

        <div id="keywords">
          <h1>Keywords</h1>

          <ul class="list-inline comma-separated">
            <li>Conceptual Model</li>

            <li>Design Model</li>

            <li>Information Model</li>

            <li>Process Model</li>
          </ul>
        </div>

        <section id="sect0" role="doc-abstract">
          <h1>Abstract</h1>

          <p>In simulation engineering, a system model mainly consists of an <em>information model</em> describing a system's state structure and a
          <em>process model</em> describing its dynamics. In the fields of <em>Information Systems</em> and <em>Software Engineering</em>, there are
          widely used standards such as the <em>Class Diagrams</em> of the <em>Unified Modeling Language (UML)</em> for making information models, and
          the <em>Business Process Modeling Notation (BPMN)</em> for making process models. This tutorial presents a general <em>Object Event Modeling
          (OEM)</em> approach for Discrete Event Simulation modeling using UML class diagrams and BPMN-based process diagrams at all three levels of
          <em>model-driven simulation engineering</em>: for making conceptual domain models, for making platform-independent simulation design models,
          and for making platform-specific, executable simulation models. In this approach, object and event types are modeled as special categories
          of UML classes, random variables are modeled as a special category of UML operations constrained to comply with a specific probability
          distribution, and queues are modeled as ordered association ends, while <em>event rules</em> are modeled both as BPMN-based process diagrams
          and pseudo-code. In <a href="https://dpmn.info/reading/Activities.html">Part II</a>, we discuss the more advanced OEM concepts of <em>activities</em>
		  and GPSS/SIMAN/Arena-style <em>Processing Networks</em>. Finally, in Part III, we further extend the OEM paradigm towards agent-based
		  modeling and simulation by adding the concepts of <em>agents</em> with <em>perceptions</em>, <em>actions</em> and <em>beliefs</em>.</p>
        </section>
      </div>

      <section id="sect1">
        <h1>Introduction</h1>

        <p>The term <em>simulation engineering</em> denotes the scientific engineering discipline concerned with the development of computer
        simulations, which are a special class of software applications. Since a running computer simulation is a particular kind of software system,
        we may consider simulation engineering as a special case of <em>software engineering</em>.</p>

        <p>Although there is a common agreement that modeling is an important first step in a simulation project, it is also thought to be the least
        understood part of simulation engineering (<a href="#Tak10">Tako, Kotiadis, &amp; Vasilakis, 2010</a>). In a panel discussion on conceptual
        simulation modeling (<a href="#Dur10">Zee et al., 2010</a>), the participants agreed that there is a lack of <q>standards, on procedures,
        notation, and model qualities</q>. On the other hand, there is no such lack in the field of <em>Information Systems and Software Engineering
        (IS/SE)</em> where standards such as the <em>Unified Modeling Language (UML)</em> and the <em>Business Process Modeling Notation (BPMN)</em>
        have been widely adopted, and various modeling methodologies and model quality assurance methods have been established.</p>

        <p>The standard view in the simulation literature, see, e.g., (<a href="#Himmelspach2009">Himmelspach, 2009</a>), is that a <em>simulation
        model</em> can be expressed either in a general purpose programming language or in a specialized simulation language. However, the term
        <q>model</q> in <em>simulation model</em> typically refers to a low-level computer program rather than a higher-level representation expressed
        in a diagrammatic modeling language. In a <em>modeling and simulation</em> project, despite the fact that <q>modeling</q> is part of the
        discipline’s name, often no information or process models are produced, but rather the modeler jumps from her mental model to its
        implementation in some target technology platform. Clearly, as in IS/SE, making conceptual models and design models is important for several
        reasons: as opposed to a low-level computer program, a high-level model is more comprehensible and easier to communicate, share, reuse,
        maintain and evolve. Furthermore, it can also be used for obtaining platform-specific implementation code, possibly with the help of <em>model
        transformations</em> and <em>code generation</em>.</p>

        <p>Due to their expressiveness and wide adoption as modeling standards, UML and BPMN seem the most appropriate choices as information and
        process modeling languages for a model-based simulation engineering approach. However, since they have not been designed for this purpose, we
        may have to restrict, modify and extend them in a suitable way.</p>

        <p>Several authors, e.g., (<a href="#Wag09">Wagner, Nicolae, &amp; Werner, 2009</a>), (<a href="#CetinkayaVS2011">Cetinkaya, Verbraeck, &amp;
        Seck, 2011</a>), and (<a href="#Ong11">Onggo &amp; Karpat, 2011</a>), have proposed to use BPMN for Discrete Event Simulation (DES) modeling
        and for agent-based modeling. However, process modeling in general is much less understood than information modeling, and there are no
        guidelines and no best practices how to use BPMN for simulation modeling. Schruben (<a href="#LSch83">1983</a>), with his <em>Event Graph</em>
        diagram language, has pioneered the research on process modeling languages for DES based on the modeling concept of <em>event types</em> and
        the operational semantics concept of <em>event scheduling</em> with a <em>future events list</em>. Remarkably, Event Graphs correspond to a
        fragment of BPMN (without Activities and Pools), which indicates the potential of BPMN as a basis of a general process modeling language for
        DES.</p>

        <p>This tutorial article extends and improves the modeling approach presented in (<a href="#GWa17b">Wagner, 2017b</a>). In particular, the
        BPMN-based process design modeling approach has been revised and refined by using a variant of BPMN, called <em>Discrete Event Process
        Modeling Notation (DPMN)</em>, which is discussed in <a href="#sect5">Section 5</a>.</p>

        <p>This first part of the tutorial presents the <em>Object-Event Modeling (OEM)</em> paradigm and an OEM approach for developing basic
        discrete event simulations. First, short introductions to model-driven engineering, to information modeling with UML class diagrams, and to
        process modeling with BPMN and DPMN process diagrams are presented. Next, two examples are provided to illustrate how to apply the OEM
        paradigm to developing discrete event simulations. In <a href="https://dpmn.info/reading/Activities.html">Part II</a> of this tutorial,
		we discuss the more advanced modeling concepts of
        <em>activities</em> and GPSS/SIMAN/Arena-style <em>Processing Networks</em> where work objects <q>flow through the system</q> by entering it
        through an <em>arrival event</em> at an <em>entry node</em>, then passing one or more <em>processing nodes</em>, where processing activities
        are being performed, and finally leaving it through a <em>departure event</em> at an <em>exit node</em>. Finally, Part III will show how to
        add the modeling concepts of <em>agents</em> with <em>perceptions</em>, <em>actions</em> and <em>beliefs</em>, resulting in a general
        agent-based DES modeling framework.</p>

        <p>In the OEM paradigm, the relevant <em>object types</em> and <em>event types</em> are described in an information model, which is the basis
        for making a process model. A modeling approach that follows the OEM paradigm is called an <em>OEM approach</em>. Such an approach needs to
        choose, or define, an information modeling language and a process modeling language. Possible choices are Entity Relationship Diagrams or UML
        Class Diagrams for information modeling, and UML Activity Diagrams or BPMN Process Diagrams for process modeling.</p>

        <p>We propose an OEM approach based on UML Class Diagrams for conceptual information modeling and information design modeling, as well as BPMN
        Process Diagrams for conceptual process modeling and DPMN Process Diagrams for process design modeling. In the proposed approach, object types
        and event types are modeled as special categories of classes in a UML Class Diagram. <em>Random variables</em> are modeled as a special
        category of class-level operations constrained to comply with a specific probability distribution such that they can be implemented as static
        methods of a class. <em>Queues</em> are not modeled as objects, but rather as ordered association ends, which can be implemented as
        collection-valued reference properties. Finally, <em>event rules</em>, which include <em>event routines</em>, are modeled both as BPMN/DPMN
        process diagrams and in pseudo-code such that they can be implemented in the form of special <em>onEvent</em> methods of event classes.</p>

        <p>An OEM approach results in a simulation design model that has a well-defined operational semantics, as shown in (<a href="#GWa17a">Wagner,
        2017a</a>). Such a model can, in principle, be implemented with any object-oriented (OO) simulation technology. However, a straightforward
        implementation can only be expected from a technology that implements the <em>Object-Event Simulation (OES)</em> paradigm proposed in (<a href="#GWa17a">Wagner, 2017a</a>), such as the <em>OES JavaScript (OESjs)</em> framework presented in (<a href="#GWa17c">Wagner,
        2017c</a>).</p>

        <p>There are two examples of systems, which are paradigmatic for DES (and for <em>operations research</em>): <em>service/processing
        systems</em> with queues (also called <q>queuing networks</q>) and <em>inventory management systems</em>. However, neither of them has yet
        been presented with elaborate information and process models in tutorials or textbooks. In this tutorial, we show how to make information and
        process models of an inventory management system and of a service system, and how to code them using the JavaScript-based simulation framework
        OESjs.</p>
      </section>

      <section id="sect2">
        <h1>What Is Discrete Event Simulation?</h1>

        <p>The term <em>Discrete Event Simulation (DES)</em> has been established as an umbrella term subsuming various kinds of computer simulation
        approaches, all based on the general idea of modeling entities/objects and events. In the DES literature, it is often stated that DES is based
        on the concept of <q>entities flowing through the system</q> (more precisely, through a <q>queueing network</q>). This is the paradigm of an
        entire class of simulation software in the tradition of GPSS (<a href="#Gordon61">Gordon, 1961</a>) and SIMAN/Arena (<a href="#Peg92">Pegden
        &amp; Davis, 1992</a>). However, this paradigm characterizes a special (yet important) class of DES only, it does not apply to all discrete
        dynamic systems.</p>

        <p>In Ontology, which is the philosophical study of what there is, <b><i>entities</i></b> (also called <em>individuals</em>) are distinguished from <b><i>entity types</i></b> (called <em>universals</em>). There are three fundamental categories of entities:</p>

        <ol>
          <li><b>
              <i>objects</i>
            </b>,</li>

          <li><b>
              <i>tropes</i>
            </b>, which are existentially dependent entities such as the <em>qualities</em> and <em>dispositions</em> of objects and their
          <em>relationships</em> with each other, and</li>

          <li><b>
              <i>events</i>
            </b>.</li>
        </ol>

        <p>These ontological distinctions are discussed, e.g., by Guizzardi and Wagner (<a href="#GuizzardiW2010a">2010a</a>, <a href="#GuizzardiW2010b">2010b</a>, <a href="#GuizzardiW2013">2013</a>).</p>

        <p>While the concept of an event is often limited to instantaneous events in the area of DES, the general concept of an event, as discussed in
        philosophy and in many fields of computer science, includes composite events and events with non-zero duration.</p>

        <p>A <em>discrete event system</em> (or <em>discrete dynamic system</em>) consists of</p>

        <ul>
          <li>objects (of various types) having a state (consisting of qualities) and dispositions,</li>

          <li>events (of various types) triggering certain dispositions of objects participating in them,</li>
        </ul>

        <p>such that the states of affected objects may be changed by events according to the dispositions triggered by them. It is natural to
        consider the concept of <em>discrete events</em>, occurring at times from a discrete set of time points.</p>

        <p>For modeling a discrete event system as a state transition system, we have to describe its</p>

        <ol>
          <li><b>
              <i>object types</i>
            </b>, e.g., in the form of <em>classes</em> of an object-oriented language;</li>

          <li><b>
              <i>event types</i>
            </b>, e.g., in the form of <em>classes</em> of an object-oriented language;</li>

          <li><b>
              <i>causal regularities</i>
            </b> (<em>disposition types</em>) e.g., in the form of <em>event rules</em>.</li>
        </ol>

        <p>Any DES formalism has one or more language elements that allow specifying <em>event rules</em> representing causal regularities. These
        rules specify, for any event type, the <em>state changes</em> of objects and the <em>follow-up events</em> caused by the occurrence of an
        event of that type, thus defining the dynamics of the transition system. Unfortunately, this is often obscured by the standard definitions of
        DES that are repeatedly presented in simulation textbooks and tutorials.</p>

        <p>According to Pegden (<a href="#Peg10">2010</a>), a <em>simulation modeling worldview</em> provides <q>a framework for defining a system in
        sufficient detail that it can be executed to simulate the behavior of the system</q>. It <q>must precisely define the dynamic state
        transitions that occur over time</q>. Pegden explains that the 50 year history of DES has been shaped by three fundamental paradigms:
        Markowitz, Hausner, and Karr (<a href="#MarkHK62">1962</a>) pioneered the <em>event worldview</em> with <em>SIMSCRIPT</em>, Gordon (<a href="#Gordon61">1961</a>) pioneered the <em>processing network worldview</em> with <em>GPSS</em>, and Dahl and Nygaard (<a href="#DahlNygaard66">1966</a>) pioneered the <em>object worldview</em> with <em>Simula</em>. Pegden characterizes these paradigms in the
        following way:</p>

        <p><b><i>Event worldview</i></b>: The system is viewed as a series of instantaneous events that change the state of the system over time. The modeler defines the events
        in the system and models the state changes that take place when those events occur. According to Pegden, the event worldview is the most
        fundamental worldview since the other worldviews also use events, at least implicitly.</p>

        <p><b><i>Processing Network worldview</i></b>: The system under investigation is described as a processing network where <q>entities flow through the system</q> (or, more precisely,
        work objects are routed through the network) and are subject to a series of processing steps performed at processing nodes through processing
        activities, possibly requiring resources and inducing queues of work objects waiting for the availability of resources (processing networks
        have been called <q>queueing networks</q> in Operations Research). This approach allows high-level modeling with semi-visual languages and is
        therefore the most widely used DES approach nowadays, in particular in manufacturing industries and service industries. Simulation platforms
        based on this worldview may or may not support object-oriented modeling and programming.</p>

        <p><b><i>Object worldview</i></b>: The system is modeled by describing the objects that make up the system. The system behavior emerges from the <q>interaction</q> of
        these objects.</p>

        <p>All three worldviews lack important conceptual elements. The event worldview does not consider objects with their (categorical and
        dispositional) properties. The processing network worldview neither considers events nor objects. And the object worldview, while it considers
        objects with their <em>categorical</em> properties, does not consider events. None of the three worldviews includes modeling the
        <em>dispositional</em> properties of objects with a full-fledged explicit concept of <em>event rules</em>.</p>

        <p>The event worldview and the object worldview can be combined in approaches that support both objects and events as first-class citizens.
        This seems highly desirable because (1) objects (and classes) are a must-have in today’s state-of-the-art modeling and programming, and (2) a
        general concept of events is fundamental in DES, as demonstrated by the classical event worldview. We use the term <em>object-event
        worldview</em> for any DES approach combining OO modeling and programming with a general concept of events.</p>
      </section>

      <section id="sect3">
        <h1>Model-Driven Engineering</h1>

        <p><em>Model-Driven Engineering</em> (MDE), also called <em>model-driven development</em>, is a well-established paradigm in IS/SE. Since
        simulation engineering can be viewed as a special case of software engineering, it is natural to apply the ideas of MDE also to simulation
        engineering. There have been several proposals of using an MDE approach in Modeling and Simulation (M&amp;S), see, e.g., the overview given in
        (<a href="#Cet11">Cetinkaya &amp; Verbraeck, 2011</a>).</p>

        <p>In MDE, there is a clear distinction between three kinds of models as engineering artifacts created in the analysis, design and
        implementation phases of a development project:</p>

        <ol>
          <li><em>domain models</em> (also called <em>conceptual models</em>), which are solution-independent,</li>

          <li><em>design models</em>, which represent platform-independent solution designs,</li>

          <li><em>implementation models</em>, which are platform-specific.</li>
        </ol>

        <p>Domain models are solution-independent descriptions of a problem domain produced in the analysis phase. We follow the IS/SE usage of the
        term <q>conceptual model</q> as a synonym of <q>domain model</q>. However, in the M&amp;S literature there are diverging proposals how to
        define the term <q>conceptual model</q>, see, e.g., (<a href="#GuizzardiW2012">Guizzardi &amp; Wagner, 2012</a>) and (<a href="#Rob13">Robinson, 2013</a>). A domain model may include both descriptions of the domain’s state structure (in conceptual <em>information
        models</em>) and descriptions of its processes (in conceptual <em>process models</em>). They are solution-independent, or
        <q>computation-independent</q>, in the sense that they are not concerned with making any system design choices or with other computational
        issues. Rather, they focus on the perspective and language of the subject matter experts for the domain under consideration.</p>

        <p>In the design phase, first a platform-independent design model, as a general computational solution, is developed on the basis of the
        domain model. The same domain model can potentially be used to produce a number of (even radically) different design models. Then, by taking
        into consideration a number of implementation issues ranging from architectural styles, nonfunctional quality criteria to be maximized (e.g.,
        performance, adaptability) and target technology platforms, one or more platform-specific implementation models are derived from the design
        model. These one-to-many relationships between conceptual models, design models and implementation models are illustrated in <a href="#_Ref493009969">Figure 1</a>.</p>

        <figure class="top" id="_Ref493009969" data-enlarge-by="0.5">
          <img src="./img/MDD.svg" width="600">

          <figcaption><strong>Figure 1.</strong> From a conceptual model via design models to implementation models.</figcaption>
        </figure>

        <p>In the implementation phase, an implementation model is coded in the programming language of the target platform. Finally, after testing
        and debugging, the implemented solution is then deployed in a target environment.</p>

        <p>A model for a software (or information) system, which may be called a <q>software system model</q>, does not consist of just one model
        diagram including all viewpoints or aspects of the system to be developed (or to be documented). Rather it consists of a set of models, one
        (or more) for each viewpoint. The two most important viewpoints, crosscutting all three modeling levels: domain, design and implementation,
        are</p>

        <ol>
          <li>
            <p><b>
                <i>information modeling</i>
              </b>, which is concerned with the <b>
                <i>state structure</i>
              </b> of the domain, design or implementation;</p>
          </li>

          <li>
            <p><b>
                <i>process modeling</i>
              </b>, which is concerned with the <b>
                <i>dynamics</i>
              </b> of the domain, design or implementation.</p>
          </li>
        </ol>

        <p>In the computer science field of database engineering, which is only concerned with information modeling, domain information models have
        been called <q>conceptual models</q>, information design models have been called <q>logical design models</q>, and database implementation
        models have been called <q>physical design models</q>. Information implementation models are called <em>data models</em> or <em>class
        models</em>. So, from a given information design model, we may derive an SQL data model, a Java class model and a C# class model.</p>

        <p>Examples of widely used languages for information modeling are <em>Entity Relationship (ER) Diagrams</em> and <em>UML Class Diagrams</em>.
        Since the latter subsume the former, we prefer using UML class diagrams for making all kinds of information models, including SQL database
        models.</p>

        <p>Examples of widely used languages for process modeling are <em>(Colored) Petri Nets</em>, <em>UML Sequence Diagrams,</em> <em>UML Activity
        Diagrams</em> and the <em>BPMN</em>. Notice that there is more agreement on the right concepts for information modeling than for process
        modeling, as indicated by the much larger number of different process modeling languages. We claim that this reflects a lower degree of
        understanding the nature of events and processes compared to understanding objects and their relationships.</p>

        <p>Some modeling languages, such as UML Class Diagrams and BPMN, can be used on all three modeling levels in the form of tailored variants.
        Other languages have been designed for being used on one or two of these three levels only. For instance, Petri Nets cannot be used for
        conceptual process modeling, since they lack the required expressiveness.</p>

        <figure class="top" id="_Ref493010044" data-enlarge-by="0.5">
          <img src="./img/MDD-Example.svg" width="800">

          <figcaption><strong>Figure 2.</strong> From a conceptual information model via a design model to OO and C++ class models.</figcaption>
        </figure>

        <p>We illustrate the distinction between the three modeling levels with an example in <a href="#_Ref493010044">Figure 2</a>. In a simple
        conceptual information model of people, expressed as a UML class diagram, we require that any person has exactly one mother, expressed by a
        corresponding binary many-to-one association, while we represent this association with a corresponding reference property <em>mother</em> in
        the OO and C++ class models. Also, we may not care about the datatypes of attributes in the conceptual model, while we do care about them in
        the design model, where we use platform-independent datatype names (such as <code>Decimal</code> ), and in the C++ class model where we use
        C++ datatypes (such as <code>double</code> ). Following OO programming conventions, we add <em>get</em> and <em>set</em> methods for all
        attributes, and we specify the visibility <em>private</em> (symbolically -) for attributes and <em>public</em> (symbolically +) for methods,
        in the OO class model. Finally, in the C++ class model, we use the pointer type <code>Person*</code> instead of <code>Person</code> for
        implementing a reference property.</p>

        <p>Model-driven simulation engineering is based on the same kinds of models as model-driven software engineering: going from a <em>domain
        model</em> via a<em> design model</em> to an <em>implementation model</em> for the simulation platform of choice (or to several implementation
        models if there are several target simulation platforms). The specific concerns of simulation engineering, like, e.g., the concern to capture
        certain parts of the overall system dynamics with the help of random variables, do not affect the applicability of MDE principles. However,
        they define requirements for the modeling languages to be used.</p>
      </section>

      <section id="sect4">
        <h1>Information Modeling with UML Class Diagrams</h1>

        <p>Conceptual information modeling is mainly concerned with describing the relevant <b><i>entity types</i></b> of a real-world domain and the relationships between them, while information design and implementation modeling is concerned with
        describing the <em>logical</em> (or <em>platform-independent</em>) and <em>platform-specific</em> data structures (in the form of <b><i>classes</i></b>) for designing and implementing a software system or simulation. The most important kinds of relationships between entity types to be
        described in an information model are <b><i>associations</i></b>, which are called <q>relationship types</q> in <em>ER modeling</em>, and
		<b><i>subtype</i></b>/<em>supertype</em> relationships, which are called <q>generalizations</q> in <em>UML</em>. In addition, one may model various kinds of
        <em>part-whole</em> relationships between different kinds of aggregate entities and component entities, but this is an advanced topic that is
        not covered in this tutorial.</p>

        <p>As explained in the introduction, we are using the visual modeling language of UML Class Diagrams for information modeling. In this
        language, an entity type is described with a name, and possibly with a list of <b><i>properties</i></b> and <b><i>operations</i></b> (called <em>methods</em> when implemented), in the form of a <em>class rectangle</em> with one, two or three compartments, depending on
        the presence of properties and operations. <b><i>Integrity constraints</i></b>, which are conditions that must be satisfied by the instances of a type, can be expressed in special ways when defining properties or they can be explicitly attached to an entity type in the form of an <em>invariant</em> box.</p>

        <p>An <b><i>association</i></b> between two entity types is expressed as a connection line between the two class rectangles representing the entity types. The
        connection line is annotated with <em>multiplicity</em> expressions at both ends. A <b><i>multiplicity</i></b> expression has the form <code>m..n</code> where <i>m</i> is a non-negative natural number denoting the <em>minimum cardinality</em>,
        and <i>n</i> is a positive natural number (or the special symbol * standing for <em>unbounded)</em> denoting the maximum cardinality, of the
        sets of associated entities. Typically, a multiplicity expression states an integrity constraint. For instance, the multiplicity expression
        <code>1..3</code> means that there are at least 1 and at most 3 associated entities. However, the special multiplicity expression
        <code>0..*</code> (also expressed as <code>*</code> ) means that there is no constraint since the minimum cardinality is zero and the maximum
        cardinality is unbounded.</p>

        <p>For instance, the model shown in <a href="#_Ref493010135">Figure 3</a> describes the entity types <code>Shop</code> and
        <code>Delivery</code>, and it states that</p>

        <ol>
          <li>there are two classes: <code>Shop</code> and <code>Delivery</code>, representing entity types;</li>

          <li>there is a one-to-many association between the classes <code>Shop</code> and <code>Delivery</code>, where a shop is the
          <code>receiver</code> of a delivery.</li>
        </ol>

        <figure id="_Ref493010135" data-enlarge-by="0.5">
          <img src="./img/IntroUML1.svg" width="400">

          <figcaption><strong>Figure 3.</strong> The entity types Shop and Delivery.</figcaption>
        </figure>

        <p>Using further compartments in class rectangles, we can add properties and operations. For instance, in the model shown in <a href="#_Ref493071591">Figure 4</a>, we have added</p>

        <ol>
          <li>the properties <em>name</em> and <em>stockQuantity</em> to <code>Shop</code> and <em>quantity</em> to <code>Delivery</code>,</li>

          <li>the instance-level operation <em>onEvent</em> to <code>Delivery</code>,</li>

          <li>the class-level operation <em>leadTime</em> to <code>Delivery</code>.</li>
        </ol>

        <figure id="_Ref493071591" data-enlarge-by="0.5">
          <img src="./img/IntroUML2.svg" width="450">

          <figcaption><strong>Figure 4.</strong> Adding properties and operations.</figcaption>
        </figure>

        <p>Notice that in <a href="#_Ref493071591">Figure 4</a>, each property is declared together with a datatype as its <em>range</em>. Likewise,
        operations are declared with a (possibly empty) list of parameters, and with an optional return value type. When an operation (or property)
        declaration is underlined, this means that it is class-level instead of instance-level. For instance, the underlined operation declaration
        <u><code>leadTime(): Decimal</code></u> indicates that <em>leadTime</em> is a class-level operation that does not take any argument and returns a
        decimal number.</p>

        <p>We may want to define various types of integrity constraints for better capturing the semantics of entity types, properties and operations.
        The model shown in <a href="#_Ref493014282">Figure 5</a> contains an example of a property constraint and an example of an operation
        constraint. These types of constraints can be expressed within curly braces appended to a property or operation declaration. The keyword
        <code>id</code> in the declaration of the property <code>name</code> in the <code>Shop</code> class expresses an ID constraint stating that
        the property is a standard identifier, or primary key, attribute. The expression <code>Exp(0.5)</code> in the declaration of the random
        variable operation <code>leadTime</code> in the <code>Delivery</code> class denotes the constraint that the operation must implement the
        <em>exponential</em> probability distribution function with event rate 0.5.</p>

        <figure id="_Ref493014282" data-enlarge-by="0.5">
          <img src="./img/IntroUML3.svg" width="500">

          <figcaption class="multi-line-pdf"><strong>Figure 5.</strong> Adding a property constraint and an operation constraint.</figcaption>
        </figure>

        <p>UML allows defining special categories of modeling elements called <q>stereotypes</q>. For instance, for distinguishing between <b><i>object types</i></b> and <b><i>event types</i></b> as two different categories of entity types we can define corresponding stereotypes of UML classes («object type» and «event type») and
        use them for categorizing classes in class models, as shown in <a href="#_Ref493015782">Figure 6</a>.</p>

        <figure id="_Ref493015782" data-enlarge-by="0.5">
          <img src="./img/IntroUML4.svg" width="500">

          <figcaption class="multi-line-pdf"><strong>Figure 6.</strong> Object and event types as two different categories of entity
          types.</figcaption>
        </figure>

        <p>Another example of using UML’s stereotype feature is the designation of an operation as a function that represents a <em>random
        variable</em> using the operation stereotype «rv» in the diagram of <a href="#_Ref493015782">Figure 6</a>.</p>

        <p>A class may be defined as <em>abstract</em> by writing its name in italics, as in the example model of <a href="#_Ref493094582">Figure
        11</a>. An abstract class cannot have direct instances. It can only be indirectly instantiated by objects that are direct instances of a
        subclass.</p>

        <p>For a short introduction to UML Class Diagrams, the reader is referred to (<a href="#Ambler2010">Ambler, 2010</a>). A good overview of the
        most recent version of UML (UML 2.5) is provided by <a href="https://www.uml-diagrams.org/uml-25-diagrams.html">www.uml-diagrams.org/uml-25-diagrams.html</a></p>
      </section>

      <section id="sect5">
        <h1>Process Modeling with BPMN and DPMN</h1>

        <p>The <em>Business Process Modeling Notation (BPMN)</em> is an activity-based graphical modeling language for defining business processes
        following the flow-chart metaphor. In 2011, the Object Management Group has released version 2.0 of BPMN with an optional execution semantics
        based on Petri-net-style <em>token flows</em>.</p>

        <p>The most important elements of a BPMN process model are listed in <a href="#_Ref463198942">Table 1</a>.</p>

        <table class="top" id="_Ref463198942">
          <caption><strong>Table 1.</strong> Basic elements of BPMN.</caption>

          <colgroup>
            <col span="1">

            <col span="1">

            <col span="1" style="width: 30%;">
          </colgroup>

          <thead>
            <tr>
              <th>Name of element</th>

              <th>Meaning</th>

              <th>Visual symbol(s)</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
                <p>Event</p>
              </td>

              <td>
                <p>Something that <q>happens</q> during the course of a process, affecting the process flow.</p>

                <p>A <em>Start Event</em> is drawn as a circle with a thin border line, while an <em>Intermediate Event</em> has a double border line
                and an <em>End Event</em> has a thick border line.</p>
              </td>

              <td>
                <img src="./img/Events.svg">
              </td>
            </tr>

            <tr>
              <td>
                <p>Activity</p>
              </td>

              <td>
                <p>
                  <q>Work that is performed within a Business Process.</q>
                </p>

                <p>A <em>Task</em> is an atomic Activity, while a <em>Sub-Process</em> is a <em>composite</em> Activity. A Sub-Process can be either
                in a <em>collapsed</em> or in an <em>expanded</em> view. The latter shows its internal process structure.</p>
              </td>

              <td>
                <img src="./img/Activity.svg">
              </td>
            </tr>

            <tr>
              <td>
                <p>Gateway</p>
              </td>

              <td>
                <p>A Gateway is a node for branching or merging control flows. A Gateway with an "X" symbol denotes an Exclusive OR-Split for
                conditional branching, if there are 2 or more output flows, or an Exclusive OR-Join, if there are 2 or more input flows. A Gateway
                with a plus symbol denotes an AND-Split for parallel branching, if there are 2 or more output flows, or an AND-Join, if there are 2 or
                more input flows. A Gateway can have both input and output flows.</p>
              </td>

              <td>
                <img src="./img/Gateways.svg">
              </td>
            </tr>

            <tr>
              <td>
                <p>Sequence Flow</p>
              </td>

              <td>
                <p>An arrow expressing the temporal order of Events, Activities, and Gateways. A <em>Conditional Sequence Flow</em> arrow starts with
                a diamond and is annotated with a condition (in brackets).</p>
              </td>

              <td>
                <img src="./img/image11.png">

                <img src="./img/ConditionalSequenceFlow.svg">
              </td>
            </tr>

            <tr>
              <td>
                <p>Data Object</p>
              </td>

              <td>
                <p>Data Objects may be attached to Events or Activities, providing a context for reading/writing data. A unidirectional dashed arrow
                denotes reading, while a bidirectional dashed arrow denotes reading/writing.</p>
              </td>

              <td>
                <img src="./img/DataObject.svg">
              </td>
            </tr>

            <!--
         <tr>
      <td>
         <p>Pool</p>
      </td>
      <td>
         <p>Represents an agent role (like 'Buyer' or 'Seller') or a specific instance of such
            a role (like 'Amazon.com'').
         </p>
      </td>
      <td>
            <img src="./img/image12.png"/>
      </td>
         </tr>
         <tr>
      <td>
         <p>Message Flow</p>
      </td>
      <td>
         <p>Represents a message exchange communication link between two Pools. It’s an option
            to render the message type with a message icon.
         </p>
      </td>
      <td>
            <img src="./img/image13.png"/>
      </td>
         </tr>
         -->
          </tbody>
        </table>

        <p>BPMN process diagrams can be used for making</p>

        <ol>
          <li>
            <p><b>
                <i>conceptual process models</i>
              </b>, e.g., for documenting existing business processes and for designing new business processes;</p>
          </li>

          <li>
            <p><b>
                <i>process automation models</i>
              </b> for specific process automation platforms (that allow partially or fully automating a business process) by adding platform-specific
            technical details in the form of model annotations that are not visible in the diagram.</p>
          </li>
        </ol>

        <p>However, the BPMN process diagram language has several semantic issues and is not expressive enough for making platform-independent
        computational <em>process design models</em> that can be used both for designing DES models and as a general basis for deriving
        platform-specific process automation models.</p>

        <p>For an introductory BPMN tutorial, the reader is referred to (<a href="#Camunda2017">BPMN 2.0 Tutorial, 2017</a>). A good modeling tool,
        with the advantages of an online solution, is the <a href="https://www.signavio.com/bpm-academic-initiative/"><em>Signavio Process Editor</em></a>,
		which is free for academic use.</p>

        <p>Ontologically, BPMN <em>activities</em> (or, more precisely, <em>activity types</em>) are special event types. However, the subsumption of
        activities under events is not supported by the standard semantics of BPMN.</p>

        <p>Another severe issue of the official BPMN (token flow) semantics is its limitation to <em>case handling</em> processes. Each start event
        represents a new case and starts a new process for handling this case in isolation from other cases. This semantics disallows, for instance,
        to model processes where several cases are handled in parallel and interact in some way, e.g., by competing for resources. Consequently, this
        semantics is inadequate for capturing the overall process of a business system with many actors performing tasks related to many cases with
        various interdependencies, in parallel.</p>

        <p>Despite these issues, using BPMN as a basis for developing a process design modeling approach is the best choice of a modeling language we
        can make, considering the alternatives, which are either not well-defined (like <em>Flow Charts</em> or <q>Logic Flow Diagrams</q>) or not
        sufficiently expressive (Petri Nets, UML State Transition Diagrams, UML Activity Diagrams).</p>

        <p>We need to adapt the language of BPMN Process Diagrams for the purpose of simulation design modeling where a process model must represent a
        computationally complete process specification. While we can use large parts of its vocabulary, visual syntax and informal semantics, we need
        to modify them for a number of modeling elements. The resulting BPMN variant, which is fully described in (<a href="#GWa18">Wagner, 2018</a>),
        is called <em>Discrete Event Process Modeling Notation (DPMN)</em>. It may be viewed as a BPMN-based generalization of the <em>Event
        Graph</em> diagrams of (<a href="#LSch83">Schruben 1983</a>).</p>

        <p><em>DPMN</em> adopts and adapts the syntax and semantics of BPMN in the following way:</p>

        <ol>
          <li>A DPMN diagram has an underlying UML class diagram defining its (object and event) types.</li>

          <li>DPMN Sequence Flow arrows pointing to an event circle denote <em>event scheduling</em> control flows. They must be annotated by event
          attribute assignments for creating/scheduling a new event.</li>

          <li>DPMN has three special forms of Text Annotation: <ol>
              <li>Text Annotations attached to Event circles for declaring event rule variables,</li>

              <li>Text Annotations attached to Sequence Flow arrows for state change statements,</li>

              <li>Text Annotations attached to Sequence Flow arrows pointing to Event circles for event attribute assignments.</li>
            </ol></li>

          <li>DPMN has an extended form of Data Object visually rendered as rectangles with two compartments: <ol>
              <li>a first compartment showing an object variable name and an object type name separated by a colon, together with a binding of the
              object variable to a specific object;</li>

              <li>a second compartment containing a block of state change statements (such as attribute value assignments).</li>
            </ol></li>

          <li>BPMN's temporal semantics and visual syntax distinction between Start, Intermediate and End Events is dropped. A DPMN Event circle
          implicitly represents a start (or end) Event when it has no incoming (or outgoing) Sequence Flow arrows. It represents an intermediate Event
          if it has both incoming and outgoing Sequence Flow arrows.</li>

          <li>In a DPMN <em>event rule design diagram</em>, there is exactly one start Event circle followed by zero or more end Event circles, but
          there is no intermediate Event circle.</li>

          <li>A DPMN <em>process design diagram</em> consists of an integrated set of <em>event rule design diagrams</em> such that its intermediate
          Event circles are semantically overloaded: in the context of an incoming Sequence Flow arrow they denote a scheduled event to be added to
          the <em>Future Events List (FEL)</em>, while in the context of an outgoing Sequence Flow arrow or an attached Data Object, they denote an
          event occurrence that causes state changes and follow-up events. The scheduled event and the resulting event occurrence could be separated
          by drawing two event circles that are connected by a Sequence Flow arrow denoting a <em>wait-for</em> control flow.</li>

          <li>The token flow semantics of BPMN is replaced by the operational semantics of event rules defined in (<a href="#GWa17a">Wagner,
          2017a</a>).</li>
        </ol>

        <p>A DPMN Event circle corresponds to an event type of the underlying information design model and may trigger both state changes, as
        specified in Data Object rectangles attached to the Event circle, and follow-up events, as specified by (possibly conditional) <em>event
        scheduling</em> Sequence Flow arrows.</p>
      </section>

      <section id="sect6">
        <h1>Example 1: An Inventory System</h1>

        <p>We consider a simple case of inventory management: a shop selling one product type (e.g., one model of TVs), such that its in-house
        inventory only consists of items of that type. On each business day, customers come to the shop and place their orders. If the ordered product
        quantity is in stock, customers pay their order and the ordered products are handed out to them. Otherwise, the order may still be partially
        fulfilled, if there are still some items in stock. If there are no items in stock, customers have to leave the shop without any item.</p>

        <p>When the stock quantity falls below the reorder point, a replenishment order is sent to the vendor for restocking the inventory, and the
        ordered quantity is delivered 1–3 days later.</p>

        <p>Below, a simulation of this system, based on OESjs, can be run.</p>

        <div class="iframe-container">
          <iframe id="iframe-sim4" src="https://sim4edu.com/sims/4/"></iframe>
        </div>

        <section id="sect6.1">
          <h1>Information Modeling</h1>

          <p>How should we start the information modeling process? Should we first model object types and then event types, or the other way around?
          Here, the right order is dictated by informational dependencies. Since <b><i>events are always associated with objects that participate in them</i></b>, which is an ontological pattern that is fundamental for DES, see, e.g., (<a href="#GuizzardiW2010b">Guizzardi &amp; Wagner,
          2010b</a>), we first model object types, together with their associations, and then add event types on top of them.</p>

          <p>A <b>
              <i>conceptual information model</i>
            </b> describes the subject matter vocabulary used, e.g., in the system narrative, in a semi-formal way. Such a vocabulary essentially
          consists of names for</p>

          <ol>
            <li><em>types</em>, corresponding to classes in OO modeling, or unary predicates in formal logic;</li>

            <li><em>properties</em>, corresponding to binary predicates in formal logic;</li>

            <li><em>associations</em>, corresponding to n-ary predicates (with n &gt; 1) in formal logic.</li>
          </ol>

          <p>The main categories of types are object types and event types. A simple form of conceptual information model is obtained by providing a
          list of each of them, while a more elaborated model, preferably in the form of a UML class diagram, also defines properties and
          associations, including the participation of objects (of certain types) in events (of certain types).</p>

          <p>An <b>
              <i>information design model</i>
            </b> is normally derived from a conceptual information model by choosing the design-relevant types of objects and events and enrich them
          with design details, while dropping other object types and event types not deemed relevant for the simulation design. Adding design details
          includes specifying property ranges as well as adding multiplicity and other types of constraints.</p>

          <p>In addition to these general information modeling issues, there are also a few issues, which are specific for simulation modeling:</p>

          <ol>
            <li>
              <p>Due to the ontological pattern of <b>
                  <i>objects participating in events</i>
                </b>, we always have special (participation) associations between object classes and event classes. Typically, they will have role
              names at the association ends that touch the object classes. These role names will be turned into names of corresponding reference
              properties of the event class in an OO class model, allowing the event rule method <code>onEvent</code> to access the properties of the
              objects participating in an event both for testing conditions and for applying state changes.</p>
            </li>

            <li>
              <p>Certain simulation variables may be subject to random variation, so they can be considered to be <em>random variables</em> with an
              underlying probability distribution that is sampled by a corresponding method stereotyped «rv» for categorizing it as a <em>random
              variate sampling method</em>. The underlying probability distribution can be indicated in the model diagram by appending a symbolic
              expression, denoting a distribution (with parameter values), to the method definition clause. For instance, <i>U(1,6)</i> may denote the
              uniform distribution with lower bound 1 and upper bound 6, while <i>Exp(1.5)</i> may denote the exponential distribution with event rate
              1.5.</p>
            </li>

            <li>
              <p>The information design model must distinguish between <em>exogenous</em> and <em>caused</em> (or <em>endogenous</em>) event types.
              For any exogenous event type, the recurrence of events of that type must be specified, typically in the form of a random variable, but
              in some cases it may be a constant (like 'on each Monday'). The recurrence defines the elapsed time between two consecutive events of
              the given type (their inter-occurrence time). It can be specified within the event class concerned in the form of a special method with
              the predefined name 'recurrence'.</p>
            </li>

            <li>
              <p>The queues of a queueing system are modeled in the form of <em>ordered association ends</em>, which represent
              ordered-collection-valued reference properties. For instance, in our service desk model shown in <a href="#_Ref494399721">Figure 21</a>,
              there is an association between the classes <code>ServiceDesk</code> and <code>Customer</code> with an ordered association end named
              <code>waitingCustomers</code> representing a queue. The annotation <code>{ordered}</code> means that the collection of
              <code>Customer</code> instances associated with a particular <code>ServiceDesk</code> is a linearly ordered set that allows to retrieve
              (or <em>dequeue</em>) the next customer from the <code>waitingCustomers</code> queue.</p>
            </li>
          </ol>

          <section id="sect6.1.1">
            <h1>Conceptual Information Model</h1>

            <p>We can extract the following candidates for object types from the problem description by identifying and analyzing the domain-specific
            noun phrases: <em>shops</em> (for being more precise, we also say <em>single product shops</em>), <em>products</em> (or <em>items</em>),
            <em>inventories</em>, <em>customers</em>, <em>customer orders</em>, <em>replenishment orders</em>, and <em>vendors</em>. Since noun
            phrases may also denote events (or event types), we need to take another look at our list and drop those noun phrases. We recognize that
            <em>customer orders</em> and <em>replenishment orders</em> denote messages or communication events, and not ordinary objects. This leaves
            us with the five object types described in the diagram shown in <a href="#_Ref493083679">Figure 7</a>.</p>

            <figure class="top" id="_Ref493083679" data-enlarge-by="0.5">
              <img src="./img/Inventory-ObjectTypes_CIM.svg" width="600">

              <figcaption><strong>Figure 7.</strong> A first version conceptual information model, describing object types, only.</figcaption>
            </figure>

            <p>Later, when we make a design for a simulation model we make several simplifications based on our simulation research questions. For
            instance, we may abstract away from the object types <code>products</code> and <code>vendors</code> . But in a conceptual system model, we
            include all entity types that are relevant for understanding the real-world system, independently of the simplifications we may later make
            in the solution design and implementation. This approach results in a model that can be re-used in other simulation projects with the same
            problem domain, but with different research questions.</p>

            <p>Notice that we have also modeled the following associations between these five object types:</p>

            <ol>
              <li>The (named) many-to-many association <em>customers–</em><b>
                  <i>order-from</i>
                </b><em>–shops</em>.</li>

              <li>The (un-named) one-to-one association <em>shops–</em><b>
                  <i>have</i>
                </b><em>–products</em>.</li>

              <li>The (un-named) one-to-one association <em>shops–</em><b>
                  <i>have</i>
                </b><em>–inventories</em>.</li>

              <li>The (named) many-to-one association <em>shops–</em><b>
                  <i>order-from</i>
                </b><em>–vendors</em>.</li>
            </ol>

            <p>The second association is one-to-one because we are assuming that our shops only sell a single product, while the third association is
            one-to-one because we assume that our shops only have one inventory for their single product.</p>

            <p>We have also added some attributes to the model’s object types, such as a <em>name</em> attribute for <em>customers</em>, shops,
            <em>products</em> and <em>vendors</em>, and a <em>reorder point</em> as well as a <em>stock quantity</em> attribute for
            <em>inventories</em>. Some of these attributes can be found in the problem description (such as <em>reorder point)</em>, while others have
            to be inferred by common sense reasoning (such as <em>target inventory</em> for the quantity to which the inventory is to be
            restocked<em>)</em>.</p>

            <p>In the next step, we add event types. We have already identified <em>customer orders</em> and <em>replenishment orders</em> as two
            potentially relevant event types mentioned as noun phrases in the problem description. We can try to extract the other potentially
            relevant event types from the text, typically by considering the verb phrases, such as <q>pay order</q>, <q>hand out product</q>, and
            <q>deliver</q>. For getting the names of our event types, we nominalize these verb phrases. So we get <em>customer payments</em>,
            <em>product handovers</em> and <em>deliveries</em>. Finally, for completing the model, we guess additional event types using domain
            expertise and common sense. For instance, we can imagine that a delivery by the vendor leads to a corresponding payment by the shop, so we
            also need a <em>payments</em> event type.</p>

            <p>We add these event types to our model, together with their participation associations with involved object types, now distinguishing
            class rectangles that denote event types from those denoting object types with the help of UML stereotypes, as shown in <a href="#_Ref493084409">Figure 8</a>. For visual clarity, we use classes without a stereotype for representing object types (so we can omit
            the stereotype «object type» since it is the default).</p>

            <p>Notice that a participation association between an object type and an event type is typically one-to-many, since an event of that type
            has typically exactly one participating object of that type, and, vice versa, an object of that type typically participates in many events
            of that type.</p>

            <figure class="top" id="_Ref493084409" data-enlarge-by="0.5">
              <img src="./img/Inventory_CIM.svg" width="800">

              <figcaption><strong>Figure 8.</strong> The complete conceptual information model.</figcaption>
            </figure>

            <p>Notice that, for brevity, we omitted the event type for the shop declining a customer order. Even so, the model may seem quite large
            for a problem like inventory management. However, in a conceptual model, we describe a complete system including all object and event
            types that are relevant for understanding its dynamics.</p>

            <p>Typically, in a simulation design model we would make several simplifications allowed by our research questions, and, for instance,
            abstract away from the object types <em>products</em> and <em>inventories</em>. But in a conceptual model of the system under
            investigation, we include all relevant entity types, independently of the simplifications we may later make in the solution design and
            implementation. This approach results in a conceptual model that can be re-used in other simulation projects (with different research
            questions).</p>
          </section>

          <section id="sect6.1.2">
            <h1>Information Design Model</h1>

            <p>We now derive an information design model from the solution-independent conceptual information model shown in <a href="#_Ref493084409">Figure 8</a>. Our design model is solution-specific because it is a computational design for the following specific
            research question: compute the average percentage of <em>lost sales</em> (if an order quantity is greater than the current stock level,
            the difference counts as a lost sale). Such a design model is platform-independent in the sense that it does not use any modeling element
            that is specific for a particular platform, such as a Java datatype.</p>

            <p>In the first step, we take a decision about which object types and event types defined in the conceptual model can be dropped in the
            solution design model. The goal is to keep only those entity types in the model, which are needed for being able to answer the research
            question. One opportunity for simplification is to drop <em>products</em> and <em>inventories</em> because our assumptions imply that
            there is only one product and only one inventory, so we can leave them implicit and allocate their relevant attributes to the
            <em>SingleProductShop</em> class. As this class name indicates, in the design model, we follow a widely used naming convention: the name
            of a class is a capitalized singular noun phrase in mixed case.</p>

            <p>For simplicity, we add a <em>lostSales</em> attribute to the <em>SingleProductShop</em> class for storing the lost-sales statistics for
            each shop. Alternatively, we could add a special class for defining statistics variables.</p>

            <p>Further analysis shows that we can drop the event types <em>customer payments</em> and <em>vendor payments</em>, since we do not need
            any payment data, and also <em>product handovers</em>, since we do not care about the point-of-sales logistics. This leaves us with three
            potentially relevant object types: <em>customers</em>, <em>single product shops</em> and <em>vendors</em>; and three potentially relevant
            event types: <em>customer orders</em>, <em>replenishment orders</em> and <em>deliveries</em>.</p>

            <p>There is still room for further simplification. Since for computing the percentage of lost sales, we do not need the order quantities
            of individual orders, but only the total number of ordered items, it is sufficient to model an aggregate of customer orders like the
            <em>daily demand</em>. Consequently, we do not need to consider individual customers and their orders. So, we can drop the object type
            <em>customers</em> and use the aggregate event type <em>DailyDemand</em> instead of <em>customer orders</em>. Since we do not need any
            vendor information, we can also drop the object type <em>vendors</em>.</p>

            <p>Finally, since we can now assume that replenishment orders are placed when a <em>DailyDemand</em> event has occurred, implying that any
            <em>replenishment order</em> event temporally coincides with a <em>DailyDemand</em> event, we can also drop the event type
            <em>replenishment orders</em>.</p>

            <p>Thus, the simplifications of our first design modeling step lead to a model as shown in <a href="#_Ref493086068">Figure 9</a>.</p>

            <figure class="top" id="_Ref493086068" data-enlarge-by="0.5">
              <img src="./img/Inventory_IDM-1.svg" width="500">

              <figcaption><strong>Figure 9.</strong> The initial information design model with attributes and associations (Step 1).</figcaption>
            </figure>

            <p>Notice that the two associations model the participation of the shop both in <em>DailyDemand</em> events and in <em>Delivery</em>
            events, and the association end names <em>shop</em> and <em>receiver</em> represent the reference properties <em>DailyDemand::shop</em>
            and <em>Delivery::receiver</em> (as implied by the corresponding association end ownership dots). These reference properties allow to
            access the properties and invoke the methods of a shop from an event, which is essential for the <em>event routine</em> of each event
            type. Thus, the ontological pattern of <em>objects participating in events</em> and the implied software pattern of object reference
            properties in event types are the basis for defining event routines (and rules) in event types.</p>

            <p>In the next step (step 2), we distinguish between two kinds of event types: <b>
                <i>exogenous event types</i>
              </b> and <b>
                <i>caused event types</i>
              </b>, and we also define for all attributes a platform-independent datatype as their range, using specific datatypes (such as
            <code>PositiveInteger</code> , instead of plain <code>Integer</code> , for the quantity of a delivery), as shown in <a href="#_Ref493087168">Figure 10</a>.</p>

            <figure class="top" id="_Ref493087168" data-enlarge-by="0.5">
              <img src="./img/Inventory_IDM-2.svg" width="500">

              <figcaption><strong>Figure 10.</strong> Adding the range of attributes and random variables (Step 2).</figcaption>
            </figure>

            <p>While exogenous events of a certain type occur periodically with some (typically <em>random</em>)<em> recurrence</em>, caused events
            occur at times that result from the internal causation dynamics of the simulation model. So, for any event type adopted from the
            conceptual model, we choose one of these two categories. For any exogenous event type, we add a class-level ("static") <em>recurrence</em>
            operation, which is responsible for computing the time until the next event occurs. If new exogenous events have to be created with
            specific attribute assignments, like in the case of <i>DailyDemand</i> events, which require a random variate assignment to their
            <i>quantity</i> attribute, a <i>createNextEvent</i> operation is defined for creating a new instance of the event type as its next
            occurrence.</p>

            <p>In the model shown in <a href="#_Ref493087168">Figure 10</a>, we define <em>DailyDemand</em> as an exogenous event type with a
            recurrence of 1, implying that an event of this type occurs on each day, while we define <em>Delivery</em> as a caused event type.</p>
          </section>

          <section id="sect6.1.3">
            <h1>Deriving Platform-Specific Class Models from the Information Design Model</h1>

            <p>After choosing an object-oriented simulation platform based on the object-event paradigm (e.g., the JavaScript-based platform
            <em>OESjs</em> available from <a href="https://sim4edu.com/">Sim4edu</a>, or one of the Java-based platforms <a href="http://desmoj.sourceforge.net/home.html">DESMO-J</a>, <a href="https://jaamsim.com/">JaamSim</a> or <a href="https://www.anylogic.com/">AnyLogic</a>), we can derive a platform-specific class model for this platform from the information
            design model.</p>

            <p>In the language of such a platform, there would normally be two predefined abstract foundation classes for defining object types and
            event types. For instance, in OESjs, they are called <em>oBJECT</em> and <em>eVENT</em>, each with a set of generic properties and methods
            for implementing the two stereotypes «object type» and «event type». These two classes, with their name in italics for indicating that
            they are <em>abstract</em>, are used for deriving object types and event types in the OESjs class models shown in <a href="#_Ref493094582">Figure 11</a> and <a href="#_Ref493094586">Figure 12</a>.</p>

            <figure id="_Ref493094582" data-enlarge-by="0.5">
              <img src="./img/Inventory-ObjTypes_OESjs.svg" width="320">

              <figcaption><strong>Figure 11.</strong> Defining an object class in OESjs.</figcaption>
            </figure>

            <figure id="_Ref493094586" data-enlarge-by="0.5">
              <img src="./img/Inventory-EvtTypes_OESjs.svg" width="450">

              <figcaption><strong>Figure 12.</strong> Defining event classes in OESjs.</figcaption>
            </figure>

            <p>Notice that OESjs allows using specific datatypes, like <em>PositiveInteger</em>, as the range of an attribute, while variables and
            functions are not explicitly typed in JavaScript, which only has one numeric datatype ( <code>number</code> ), not supporting the
            distinction between decimal numbers and integers.</p>

            <p>OESjs class models no longer contain any explicit associations, which have been replaced with corresponding reference properties (like
            <em>DailyDemand::shop</em> and <em>Delivery::receiver)</em>. This is the way associations are implemented in OO programming.</p>

            <p>The <em>onEvent</em> operation in the <em>eVENT</em> class is abstract, as indicated by its name in italics. It requires that any
            subclass provides a concrete <code>onEvent</code> method that implements the event routine of the event rule associated with the event
            type implemented by the <em>eVENT</em> subclass. For instance, the <code>onEvent</code> method of the subclass <em>DailyDemand</em>
            implements the event routine of the <em>DailyDemand</em> event rules, see <a href="#sect6.2.3">Section 6.2.3</a>. The return type
            declaration <code>eVENT[*]</code> means that the <code>onEvent</code> method returns a set of (follow-up) events.</p>

            <p>Notice that for handling the exogenous events of type <em>DailyDemand</em>, we have added a static <em>createNextEvent</em> method in
            <em>DailyDemand</em> for creating the next <em>DailyDemand</em> event by invoking both the <em>demandQuantity</em> method and the
            <em>recurrence</em> method, whenever a <em>DailyDemand</em> event has occurred.</p>
          </section>

          <section id="sect6.1.4">
            <h1>Coding a Platform-Specific Class Model</h1>

            <p>The classes defined in the OESjs class model shown in <a href="#_Ref493094586">Figure 12</a> can be directly coded as OESjs classes.
            For instance, the object class <em>SingleProductShop</em> can be coded in the following way:</p>

            <pre class="  language-javascript"><code class="  language-javascript"><span class="token keyword">var</span> SingleProductShop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">cLASS</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  Name<span class="token punctuation">:</span> <span class="token string">"SingleProductShop"</span><span class="token punctuation">,</span>
  supertypeName<span class="token punctuation">:</span> <span class="token string">"oBJECT"</span><span class="token punctuation">,</span>
  properties<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"stockQuantity"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>range<span class="token punctuation">:</span><span class="token string">"NonNegativeInteger"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"reorderPoint"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>range<span class="token punctuation">:</span><span class="token string">"NonNegativeInteger"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"targetInventory"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>range<span class="token punctuation">:</span><span class="token string">"PositiveInteger"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"lostSales"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>range<span class="token punctuation">:</span><span class="token string">"Percentage"</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

            <p>This class just has three simple data-valued properties (attributes), each defined with an integer range.</p>

            <p>The event class <em>DailyDemand</em> can be coded in the following way:</p>

            <pre class="  language-javascript"><code class="  language-javascript"><span class="token keyword">var</span> DailyDemand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">cLASS</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  Name<span class="token punctuation">:</span> <span class="token string">"DailyDemand"</span><span class="token punctuation">,</span>
  supertypeName<span class="token punctuation">:</span> <span class="token string">"eVENT"</span><span class="token punctuation">,</span>
  properties<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"quantity"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>range<span class="token punctuation">:</span> <span class="token string">"PositiveInteger"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">"shop"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>range<span class="token punctuation">:</span> <span class="token string">"SingleProductShop"</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"onEvent"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
DailyDemand<span class="token punctuation">.</span><span class="token function-variable function">recurrence</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
DailyDemand<span class="token punctuation">.</span><span class="token function-variable function">createNextEvent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
DailyDemand<span class="token punctuation">.</span><span class="token function-variable function">demandQuantity</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre>

            <p>Notice that in the <em>DailyDemand</em> event class, we have a reference property <code>shop</code> allowing to access the properties
            of the shop object that participates in a <em>DailyDemand</em> event. We also have an <code>onEvent</code> method for implementing the
            event rule of the <em>DailyDemand</em> event type. In this method, the reference property <code>shop</code> can be used for retrieving or
            changing the state of the shop that participates in the <em>DailyDemand</em> event. We will discuss the code of this event routine below
            in the section on implementing the process design model.</p>
          </section>
        </section>

        <section id="sect6.2">
          <h1>Process Modeling</h1>

          <p>We make a conceptual process model and a process design model for the inventory management system. These models can be expressed visually
          in the form of BPMN and DPMN process diagrams and textually in the form of <em>event rule tables</em>.</p>

          <p>A <b>
              <i>conceptual process model</i>
            </b> should include the event types identified in the conceptual information model, and describe in which temporal sequences events may
          occur, based on conditional and parallel branching. We can do this by describing, for each of the event types from the conceptual
          information model, the causal regularity associated with it in the form of an event rule that defines the state changes and follow-up events
          caused by events of that type.</p>

          <p>For simplicity, we may merge those types of events, which can be considered to temporally coincide. This is the case whenever an event
          unconditionally causes an immediately succeeding follow-up event.</p>

          <section id="sect6.2.1">
            <h1>Making a Conceptual Process Model</h1>

            <p>Since inventory management is part of a business system, it is natural to make a kind of business process (BP) model describing actors
            and their activities, typically in response to events, as shown in <a href="#_Ref493109665">Figure 13</a>, where we model the two actors
            <em>Customer</em> and <em>SingleProductShop</em>, together with their interactions.</p>

            <figure class="top" id="_Ref493109665">
              <img src="./img/Inventory_BPM.svg">

              <figcaption><strong>Figure 13.</strong> A business process model.</figcaption>
            </figure>

            <p>Notice that this traditional-style BP model suffers from the following BPMN deficiencies:</p>

            <ol>
              <li>
                <p>Activities/actions are not considered to be special events.</p>
              </li>

              <li>
                <p>There is no semantic account of the activities/actions of one actor (such as Customer) being events for another actor (such as
                Single Product Shop). In the case of outgoing message actions (<q>message tasks</q>), like <q>Place order</q>, and their corresponding
                incoming message events, like <q>CustomerOrder</q>, this relationship can be expressed with <em>message flow</em> arrows between the
                two actors involved, but in the case of non-communicative actions and events (like Customer:<q>Make payment</q> and
                Shop:CustomerPayment), BPMN does not support expressing such a relationship.</p>
              </li>
            </ol>

            <p>Also, in basic DES, we neither have an activity nor an agent concept, and therefore BPMN <em>pools</em> denoting actors, and the
            distinction between an action/activity (like <q>Place order</q>) and a corresponding event (like <q>CustomerOrder</q>) are not needed.
            Consequently, for our purpose of making a conceptual process model for basic DES, we do not use BPMN in the traditional BP modeling way,
            but rather a special form of BPMN models, without activities and without actors/swimlanes. Below, in our discussion of a service desk
            model, we will show an example of activity modeling, which requires an extended form of DES by adding an activity concept, as proposed in
            (<a href="#Wag09">Wagner, Nicolae, &amp; Werner, 2009</a>).</p>

            <p>The purpose of a conceptual process model for simulation is to identify causal regularities and express them in the form of <em>event
            rules</em>, one for each relevant type of events, at a conceptual level. We can describe event rules textually and visually in an <i>event
            rule table</i> like <a href="#_Ref494382666">Table 2</a>.</p>

            <p>We can integrate these conceptual event rule models in a conceptual process model, as shown in <a href="#_Ref493110214">Figure
            14</a>.</p>

            <figure class="top" id="_Ref493110214" data-enlarge-by="0.5">
              <img src="./img/CRM.svg">

              <figcaption><strong>Figure 14.</strong> The conceptual process model integrating all event rule models.</figcaption>
            </figure>

            <p>Notice that the BPMN End Event circles used in the event rule models may have to be converted to BPMN Intermediate Event circles in the
            integrated model.</p>

            <table class="top" id="_Ref494382666">
              <caption><strong>Table 2.</strong> Conceptual event rule models.</caption>
              <colgroup>
                <col span="1">

                <col span="1">

                <col span="1" style="width: 35%;">
              </colgroup>

              <thead>
                <tr>
                  <th>ON (event type)</th>

                  <th>DO (event routine)</th>

                  <th>Conceptual Event Rule Diagram</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td>
                    <p>customer order</p>
                  </td>

                  <td>
                    <p>check inventory;<br>if there is sufficient inventory, then product handover, else customer departure</p>
                  </td>

                  <td>
                    <img src="./img/CustomerOrder_CRM.svg">
                  </td>
                </tr>

                <tr>
                  <td>
                    <p>product handover</p>
                  </td>

                  <td>
                    <p>decrement (get product from) inventory;<br>customer payment</p>
                  </td>

                  <td>
                    <img src="./img/ProductHandover_CRM.svg">
                  </td>
                </tr>

                <tr>
                  <td>
                    <p>customer payment</p>
                  </td>

                  <td>
                    <p>customer departure</p>

                    [Notice that we do not describe the increase of the shop's cash balance due to the payment, because we focus on
                    inventory.]
                  </td>

                  <td>
                    <img src="./img/CustomerPayment_CRM.svg">
                  </td>
                </tr>

                <tr>
                  <td>
                    <p>replenishment order</p>
                  </td>

                  <td>
                    <p>delivery</p>
                  </td>

                  <td>
                    <img src="./img/ReplenishmentOrder_CRM.svg">
                  </td>
                </tr>

                <tr>
                  <td>
                    <p>delivery</p>
                  </td>

                  <td>
                    <p>increment inventory;<br>payment</p>
                  </td>

                  <td>
                    <img src="./img/Delivery_CRM.svg">
                  </td>
                </tr>
              </tbody>
            </table>
          </section>

          <section id="sect6.2.2">
            <h1>Process Design Model</h1>

            <p>A process design model needs to provide a computationally complete specification of <i>event rules</i>, one for each event type defined
            in the information design model. An event rule for a given event type essentially defines a set of (possibly conditional) state changes
            and a set of (possibly conditional) follow-up events triggered by an event of that type. We show below how a computational form of event
            rules can be visually expressed in DPMN diagrams.</p>

            <p>Since our information design model (tailored to the given research question of computing the lost sales statistics) only includes two
            event types, <em>DailyDemand</em> and <em>Delivery</em>, we need to model the two corresponding event rules, as in the event rule design
            <a href="#_Ref494385925">Table 3</a>, where these rules are modeled textually using pseudo-code.</p>

            <table class="bottom" id="_Ref494385925">
              <caption><strong>Table 3.</strong> Event rule design with pseudo-code.</caption>
              <thead>
                <tr>
                  <th>ON (event expr.)</th>

                  <th>DO (event routine)</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td>
                    <p>DailyDemand( sh, demQ) @ t</p>

                    <ul style="font-size: smaller">
                      <li>sh:SingleProductShop references the shop where the DailyDemand event happens</li>

                      <li>demQ is the daily demand quantity</li>
                    </ul>
                  </td>

                  <td>
                    <pre>                  <code>
<b>var</b> sQ := sh.stockQuantity
<b>var</b> newSQ := sQ - demQ
<b>var</b> rP := sh.reorderPoint
sh.stockQuantity := <b>max</b>( 0, newSQ)
<b>if</b> sQ &gt; rP &amp; newSQ &lt;= rP <b>then</b>
  <b>if</b> newSQ &lt; 0 <b>then</b>
    sh.lostSales += demQ - sQ
    newSQ := 0
  <b>var</b> delQ := sh.targetInventory − newSQ
  <b>schedule</b> Delivery( sh, delQ) @ t + leadTime()
                  </code>
                </pre>
                  </td>
                </tr>

                <tr>
                  <td>
                    <p>Delivery( rec, delQ) @ t</p>

                    <ul style="font-size: smaller">
                      <li>rec:SingleProductShop references the shop that is the receiver of the delivery</li>

                      <li>delQ is the delivered quantity</li>
                    </ul>
                  </td>

                  <td>
                    <pre>                  <code>
rec.stockQuantity += delQ</code>
                </pre>
                  </td>
                </tr>
              </tbody>

            </table>

            <p>Notice the general structure of an event expression like <code>DailyDemand( sh, demQ) @ t</code> : it starts with the name of an event
            type (here: <i>DailyDemand</i>) followed by a comma-separated list of event parameter names (here, <code>sh</code> and <code>demQ</code>
            ), corresponding to event attributes, and an occurrence time annotation <code>@ t</code> . The event expression is complemented with a
            parameter legend (here, <code>sh: SingleProductShop</code> ) defining the type of each event parameter.</p>

            <p>We can also express these two rules visually using the BPMN-based <em>Discrete Event Process Modeling Notation (DPMN)</em> defined in
            (<a href="#GWa18">Wagner, 2018</a>), as shown in <a href="#_Ref493110215">Figure 15</a> and <a href="#_Ref494386620">Figure 16</a>.</p>

            <figure class="top" id="_Ref493110215" data-enlarge-by="0.5">
              <img src="./img/DailyDemand_RDM.svg">

              <figcaption><strong>Figure 15.</strong> A rule design model for the event type <i>DailyDemand</i>.</figcaption>
            </figure>

            <figure id="_Ref494386620" data-enlarge-by="0.5">
              <img src="./img/Delivery_RDM.svg">

              <figcaption class="multi-line-pdf"><strong>Figure 16.</strong> A rule design model for the event type <i>Delivery</i>.</figcaption>
            </figure>

            <p>In general, a DPMN event rule design diagram contains event circles with two-part names (like <i>dd: DailyDemand</i>) specifying an
            event variable (like <i>dd</i>) and an event type (like <i>DailyDemand</i>). Event circles may be associated with one or more data object
            rectangles (like <i>sh: SingleProductShop</i>). There is exactly one start event circle without incoming arrows, which may contain rule
            variable declarations in an attached text annotation. The data object rectangles contain state change statements using the event variable
            and possibly the rule variable(s).</p>

            <p>An event circle may have one or more outgoing arrows leading to gateways or to event circles. The incoming arrows to an event circle
            represent <em>event scheduling</em> control flows. They must be annotated with event attribute assignments and an assignment of the
            scheduled event's future occurrence time <i>t'</i>, which is typically defined by adding a delay time <i>Δ</i> to the occurrence time
            <i>t</i> of the triggering event. In a DPMN diagram, the occurrence time assignment annotation <i>t' = t + Δ</i> can be abbreviated by the
            expression <i>+Δ</i>, like <i>+Delivery.leadTime()</i> in <a href="#_Ref493110215">Figure 15</a> above.</p>

            <p>Notice that <i>Delivery</i> events trigger a state change, but no follow-up events.</p>

            <p>These two event rule design models can be merged into a process design model shown in <a href="#_Ref493110216">Figure 17</a>.</p>

            <figure class="top" id="_Ref493110216" data-enlarge-by="0.5">
              <img src="./img/Inventory_PDM.svg">

              <figcaption><strong>Figure 17.</strong> A process design model in the form of a DPMN diagram.</figcaption>
            </figure>
          </section>

          <section id="sect6.2.3">
            <h1>Implementing the Process Design Model with OESjs</h1>

            <p>The process design model specifies a set of event rules, each of which can be implemented with OESjs by coding its event routine in the
            <code>onEvent</code> method of the class that represents the triggering event type. For instance, the <em>Delivery</em> event rule modeled
            in <a href="#_Ref494386620">Figure 16</a> can be coded as follows:</p>

            <pre class="  language-javascript"><code class="  language-javascript"><span class="token keyword">var</span> Delivery <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">cLASS</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  Name<span class="token punctuation">:</span> <span class="token string">"Delivery"</span><span class="token punctuation">,</span>
  supertypeName<span class="token punctuation">:</span> <span class="token string">"eVENT"</span><span class="token punctuation">,</span>
  properties<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"onEvent"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>receiver<span class="token punctuation">.</span>stockQuantity <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>quantity<span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// no follow-up events</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

            <p>Notice that while in an event rule design diagram, we declare an event variable standing for the triggering event (e.g., the variable
            <i>d</i> in <a href="#_Ref494386620">Figure 16</a>), in the corresponding event routine <code>onEvent</code> we use the special OOP
            variable <code>this</code> for the same purpose.</p>

            <p>The <em>DailyDemand</em> event rule can be coded like so:</p>

            <pre class="  language-javascript"><code class="  language-javascript"><span class="token keyword">var</span> DailyDemand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">cLASS</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  Name<span class="token punctuation">:</span> <span class="token string">"DailyDemand"</span><span class="token punctuation">,</span>
  supertypeName<span class="token punctuation">:</span> <span class="token string">"eVENT"</span><span class="token punctuation">,</span>
  properties<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"onEvent"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> sh <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>shop<span class="token punctuation">,</span>
          sQ <span class="token operator">=</span> sh<span class="token punctuation">.</span>stockQuantity<span class="token punctuation">,</span>
          newSQ <span class="token operator">=</span> sQ <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>quantity<span class="token punctuation">,</span>
          rP <span class="token operator">=</span> sh<span class="token punctuation">.</span>reorderPoint<span class="token punctuation">;</span>
      <span class="token comment">// update stockQuantity</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>shop<span class="token punctuation">.</span>stockQuantity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> newSQ<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// update lostSales if demand &gt; stock</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newSQ <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sim<span class="token punctuation">.</span>stat<span class="token punctuation">.</span>lostSales <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span> newSQ<span class="token punctuation">)</span><span class="token punctuation">;</span>
        newSQ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// schedule new Delivery if stock</span>
      <span class="token comment">// falls below reorder point</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sQ <span class="token operator">&gt;</span> rP <span class="token operator">&amp;&amp;</span> newSQ <span class="token operator">&lt;=</span> rP<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Delivery</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            occTime<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>occTime <span class="token operator">+</span> Delivery<span class="token punctuation">.</span><span class="token function">leadTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            quantity<span class="token punctuation">:</span> sh<span class="token punctuation">.</span>targetInventory <span class="token operator">-</span> newSQ<span class="token punctuation">,</span>
            receiver<span class="token punctuation">:</span> sh
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// no follow-up events</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

            <p>The full code of this simulation model is available by loading the web-based simulation <a href="https://sim4edu.com/sims/4/">https://sim4edu.com/sims/4/</a> and inspecting its JavaScript code in the browser.</p>
          </section>
        </section>
      </section>

      <section id="sect7">
        <h1>Example 2: A Service System</h1>

        <p>In our basic <a href="https://sim4edu.com/sims/2/">service system example</a>, as implemented in the <a href="https://sim4edu.com">Sim4edu</a> simulation library, customers arrive at random times at a service desk where they have to wait in a
        queue when the service desk is busy. Otherwise, when the queue is empty and the service desk is not busy, they are immediately served by the
        service clerk. Whenever a service is completed, the next customer from the queue, if there is any, is invited for the service.</p>

        <section id="sect7.1">
          <h1>Information Modeling</h1>

          <section id="sect7.1.1">
            <h1>Conceptual Information Model</h1>

            <p>It is straight-forward to extract four object types from the problem description above by analyzing the noun phrases:</p>

            <ol>
              <li>customers,</li>

              <li>service desks,</li>

              <li>service queues,</li>

              <li>service clerks.</li>
            </ol>

            <p>Thus, a first version conceptual information model of the service system may look as shown in <a href="#_Ref494397234">Figure
            18</a>.</p>

            <figure class="bottom" id="_Ref494397234" data-enlarge-by="0.5">
              <img src="./img/Service-ObjectTypes_CIM.svg" width="600">

              <figcaption><strong>Figure 18.</strong> A first version conceptual information model of a service system.</figcaption>
            </figure>

            <p>Notice that it seems preferable (more natural) to separate the service queue from the service desk and not consider the customer that
            is currently being served at the service desk to be part of the queue. Conceptually, a queue is a linearly ordered collection of objects
            of a certain type with a First-In-First-Out policy: the next object to be removed is the first object, at the front of the queue, while
            additional objects are added at the end of the queue.</p>

            <p>Notice that we model <code>customers</code> and <code>service</code> <code>clerks</code> as subclasses of <code>people</code> ,
            following a general pattern of adding a <em>base type</em> (or <em>kind</em>), such as <code>people</code> , for all <em>role</em> classes
            in a model, such as <code>customers</code> and <code>service</code> <code>clerks</code> . One of the benefits of applying this pattern is
            that we can see that a person playing the role of a service clerk may also play the role of a customer, which is a special case of the
            general possibility that an employee of an organization may also be a customer of it.</p>

            <p>After modeling all potentially relevant object types in the first step, we model the potentially relevant event types in a second
            step:</p>

            <ol>
              <li>customer arrivals,</li>

              <li>customers queuing up,</li>

              <li>customers being notified/invited to move forward to the service desk,</li>

              <li>service start,</li>

              <li>service end,</li>

              <li>customer departures.</li>
            </ol>

            <p>The main type of association between events and objects is <b>
                <i>participation</i>
              </b>. When adding event types to the object types in our conceptual information model, we therefore also model the participation types
            between them. For instance, in <a href="#_Ref494398925">Figure 19</a>, we express that a customer arrival event has exactly one customer
            and one service desk as its participants.</p>

            <figure class="top" id="_Ref494398925" data-enlarge-by="0.5">
              <img src="./img/Service_CIM.svg" width="600">

              <figcaption><strong>Figure 19.</strong> Adding event types to the conceptual information model.</figcaption>
            </figure>

            <p>In order to complete the model of <a href="#_Ref494398925">Figure 19</a>, we may add attributes that help describing objects and events
            of these types.</p>

            <p>The reader may have noticed that, while only modeling object and event types, our model does implicitly contain an activity type
            composed of the two event types <q>service start</q> and <q>service end</q>. It is well-known that, conceptually, an activity is a
            composite event that is temporally framed by a pair of start and end events. Consequently, activity types can be implicitly included in a
            basic DES model by defining corresponding pairs of start and end event types. If we would make an information model for <q>DES with
            activities</q>, which will be discussed in Part II of this tutorial, we would replace these pairs of start and end event types with
            corresponding activity types. In our example, we would replace the two event types <q>service start</q> and <q>service end</q> with the
            activity type <q>perform service</q>.</p>
          </section>

          <section id="sect7.1.2">
            <h1>Information Design Model</h1>

            <p>We now derive platform-independent <em>information design models</em> from the solution-independent <em>conceptual information
            model</em> shown in <a href="#_Ref494398925">Figure 19</a>. A design model is solution-specific because it is a computational design for
            the particular purpose of a simulation development project. For instance, the purpose may be to answer one or more specific research
            questions or to teach specific concepts/methods with an educational simulation. We consider the following two research questions:</p>

            <ol>
              <li>Compute the maximum queue length statistics.</li>

              <li>Compute the "mean response time" statistics as the average length of time a customer spends in the system from arrival to departure,
              which is the average waiting time plus the average service duration.</li>
            </ol>

            <p>Answering research question 1 does not require to model the waiting line as a queue consisting of individual customers, since for
            keeping track of the queue length and computing its maximum value, a queue length variable is sufficient and there is no need to know the
            composition of the queue and which customer is the next one to be served. The natural way for modeling the queue length variable is to
            model it as an attribute of the object type <i>ServiceDesk</i>, as in the model of <a href="#_Ref494399720">Figure 20</a>, which we also
            call <em>design model 1</em>.</p>

            <figure id="_Ref494399720" data-enlarge-by="0.5">
              <img src="./img/ServiceDesk-1_IDM.svg" width="400">

              <figcaption class="multi-line-pdf"><strong>Figure 20.</strong> An information design model for answering research question
              1.</figcaption>
            </figure>

            <p>Research question 2 requires modeling individual customers, since for being able to compute the time a customer spends in the system we
            need to know which customer is next for getting the service and what is their arrival time. For knowing which customer is next, we need to
            model the service queue as a First-In-First-Out (FIFO) queue, which can be expressed in a UML class diagram in the form of an ordered
            association end, like <code>waitingCustomers</code> in <a href="#_Ref494399721">Figure 21</a>. Notice that by placing a dot on the line at
            this end of the association, and not on the other end as well, we make the association unidirectional implying the design decision that it
            will be represented by a reference property with name <code>waitingCustomers</code> in the <code>ServiceDesk</code> class. For being able
            to easily retrieve the arrival time of a customer, which is an information item coming from the <code>CustomerArrival</code> event, we
            record it along with the customer data, so we add a corresponding attribute to the <code>Customer</code> class. The resulting <em>design
            model 2</em> is shown in <a href="#_Ref494399721">Figure 21</a>.</p>

            <figure class="top" id="_Ref494399721" data-enlarge-by="0.5">
              <img src="./img/ServiceDesk-2_IDM.svg" width="600">

              <figcaption><strong>Figure 21.</strong> An information design model for research question 2.</figcaption>
            </figure>

            <p>Concerning the event types described in the conceptual information model, the goal is to keep only those that are really needed in the
            design model. This question is closely related to the question, which types of state changes and follow-up events have to be modeled for
            being able to answer the research question(s).</p>

            <p>For both research questions, we need to keep track of changes of the queue length and in the case of research question 2, we also need
            to be able to add up the queue waiting time and the service duration for each customer. For keeping track of queue length changes, we need
            to consider all types of events that may change the queue length: <em>customer arrivals</em> and <em>customer departures</em>. For being
            able to add up the queue waiting time and the service duration, we need to catch <em>service start</em> and <em>service end
            events</em>.</p>

            <p>After identifying the relevant event types, we can look for further simplification opportunities by analyzing their possible temporal
            coincidence. Clearly, we can consider customer departures to occur immediately after the corresponding service end events, without having
            any effects that could not be merged. Therefore, we can drop service end events, and take care of their effects when handling the related
            customer departure event.</p>

            <p>In addition, we can drop service start events, since they temporally coincide with customer arrivals when the queue is empty, or
            otherwise (when the queue is not empty) they coincide with service end (and, hence, with customer departure) events, because each service
            end event causes a new service start event as long as the queue is not empty.</p>

            <p>As a result of the above considerations, we only keep the following two types of events from the conceptual model:</p>

            <ol>
              <li>
                <p><strong>
                    <code>CustomerArrival</code>
                  </strong> having two participation associations representing the reference properties: (a) <code>customer</code> with the class
                <code>Customer</code> as range, and (b) <code>serviceDesk</code> with the class <code>ServiceDesk</code> as range. As an exogenous
                event type, <code>CustomerArrival</code> has a <code>recurrence</code> function representing a random variable for computing the time
                in-between two subsequent event occurrences.</p>
              </li>

              <li>
                <p><strong>
                    <code>CustomerDeparture</code>
                  </strong> having one participation association with <code>ServiceDesk</code> representing the reference property
                <code>serviceDesk</code> .</p>
              </li>
            </ol>

            <p>Notice that, for simplicity, we consider the customer that is currently being served to be part of the queue. In this way, in the
            simulation program, we can check if the service desk is busy by testing if the length of the queue is greater than 0.</p>

            <p>An alternative approach would be not considering the currently served customer as part of the queue, but rather use a Boolean attribute
            <code>isBusy</code> for being able to keep track if the service desk is still busy with serving a customer.</p>

            <p>In an information design model we distinguish between two kinds of event types: <b>
                <i>exogenous event types</i>
              </b> and <b>
                <i>caused event types</i>
              </b>. While exogenous events of a certain type occur periodically, typically with some <em>random recurrence</em> that can be modeled
            with a probability distribution, caused events occur at times that result from the internal causation dynamics of the simulation. So, for
            any event type adopted from the conceptual model, we have to make a decision if we model it as an exogenous or as a caused event type, and
            for any exogenous event type, we specify a recurrence operation (typically a random variable) in the information design model.</p>

            <p>In both model 1 and model 2, we define <code>CustomerArrival</code> as an exogenous event type with a <code>recurrence</code> function
            that implements a random variable based on the exponential distribution with event rate 0.5, symbolically expressed as <em>Exp</em>(0.5),
            while we define <code>CustomerDeparture</code> as a caused event type.</p>

            <p>Notice that we have modeled the random duration of a service with the help of the random variable operation
            <code>serviceDuration()</code> shown in the third compartment of the <code>ServiceDesk</code> class, based on the exponential distribution
            function <em>Exp</em>(0.5). Notice also that in our design we do not need the participation association between
            <code>CustomerDeparture</code> and <code>Customer</code> since for any customer departure event the customer concerned can be retrieved by
            getting the first item from the <code>waitingCustomers</code> queue.</p>
          </section>

          <section id="sect7.1.3">
            <h1>Deriving an OESjs Class Model from an Information Design Model</h1>

            <p>We derive an OESjs class model, shown in <a href="#_Ref493094587">Figure 22</a> and <a href="#_Ref493094588">Figure 23</a>, for the
            object types and event types defined in the design model of <a href="#_Ref494399721">Figure 21</a>.</p>

            <figure id="_Ref493094587" data-enlarge-by="0.5">
              <img alt="Defining OESjs object types" src="./img/ServiceSystem-ObjTypes_OESjs.svg" width="400">

              <figcaption><strong>Figure 22.</strong> Defining object types in OESjs.</figcaption>
            </figure>

            <figure id="_Ref493094588" data-enlarge-by="0.5">
              <img alt="Defining OESjs object types" src="./img/ServiceSystem-EvtTypes_OESjs.svg" width="400">

              <figcaption><strong>Figure 23.</strong> Defining event types in OESjs.</figcaption>
            </figure>

            <p>Notice that in the OESjs class model, associations are represented by corresponding reference properties (like
            <em>ServiceDesk::waitingCustomers</em> and <em>CustomerArrival::serviceDesk)</em>.</p>
          </section>

          <section id="sect7.1.4">
            <h1>Coding the OESjs Class Model</h1>

            <p>The object class <em>ServiceDesk</em> defined in the OESjs class model shown in <a href="#_Ref493094587">Figure 22</a> can be coded as
            follows:</p>

            <pre class="  language-javascript"><code class="  language-javascript"><span class="token keyword">var</span> ServiceDesk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">cLASS</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  Name<span class="token punctuation">:</span> <span class="token string">"ServiceDesk"</span><span class="token punctuation">,</span>
  supertypeName<span class="token punctuation">:</span> <span class="token string">"oBJECT"</span><span class="token punctuation">,</span>
  properties<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"waitingCustomers"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
       range<span class="token punctuation">:</span> <span class="token string">"Customer"</span><span class="token punctuation">,</span>
       label<span class="token punctuation">:</span> <span class="token string">"Waiting customers"</span><span class="token punctuation">,</span>
       minCard<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
       maxCard<span class="token punctuation">:</span> <span class="token number">Infinity</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ServiceDesk<span class="token punctuation">.</span><span class="token function-variable function">serviceDuration</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> rand<span class="token punctuation">.</span><span class="token function">exponential</span><span class="token punctuation">(</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
          </section>
        </section>

        <section id="sect7.2">
          <h1>Process Modeling</h1>

          <section id="sect7.2.1">
            <h1>Conceptual Process Model</h1>

            <p>For brevity, we show the conceptual event rule models only for a selection of the event types from the conceptual information
            model.</p>

            <table class="top" id="_Ref494404037">
              <caption><strong>Table 4.</strong> Conceptual event rule models for the service system example.</caption>
              <colgroup>
                <col span="1">

                <col span="1">

                <col span="1" style="width: 35%;">
              </colgroup>

              <thead>
                <tr>
                  <th>ON (event type)</th>

                  <th>DO (event routine)</th>

                  <th>Conceptual Event Rule Diagram</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td>
                    <p>customer arrival</p>
                  </td>

                  <td>
                    <p>the queue (length) is incremented;<br>if there is no one else in the queue (queue length = 1), the service for the newly
                    arrived customer starts</p>
                  </td>

                  <td>
                    <img src="./img/Service-Arrival_CRM.svg">
                  </td>
                </tr>

                <tr>
                  <td>
                    <p>service start</p>
                  </td>

                  <td>
                    <p>service end</p>
                  </td>

                  <td>
                    <img src="./img/image30.png">
                  </td>
                </tr>

                <tr>
                  <td>
                    <p>service end</p>
                  </td>

                  <td>
                    <p>customer departure</p>
                  </td>

                  <td>
                    <img src="./img/Service-ServiceEnd_CRM.svg">
                  </td>
                </tr>

                <tr>
                  <td>
                    <p>customer departure</p>
                  </td>

                  <td>
                    <p>the queue (length) is decremented; if there is still someone in the queue (queue length &gt; 0), the next service starts</p>
                  </td>

                  <td>
                    <img src="./img/Service-Departure_CRM.svg">
                  </td>
                </tr>
              </tbody>
            </table>

            <p>The individual event rule models shown in <a href="#_Ref494404037">Table 4</a> can be integrated with each other as shown in <a href="#_Ref494405660">Figure 24</a> where we have to express the event types <q>service start</q>, <q>service end</q> and <q>customer
            departure</q> in the form of BPMN’s <em>intermediate events</em> for complying with the BPMN syntax.</p>

            <figure id="_Ref494405660" data-enlarge-by="0.5">
              <img src="./img/Service_CPM.svg">

              <figcaption class="multi-line-pdf"><strong>Figure 24.</strong> A conceptual process model integrating the event rule diagrams of <a href="#_Ref494404037">Table 4</a>.</figcaption>
            </figure>

            <p>If we would make a process model for a form of basic DES extended with activities, which will be discussed in Part II of this tutorial,
            we would replace the two event types <q>service start</q> and <q>service end</q> with the activity type <q>perform service</q> resulting
            in the model depicted in <a href="#_Ref499542494">Figure 25</a>.</p>

            <figure id="_Ref499542494" data-enlarge-by="0.5">
              <img src="./img/Service-with-Activity_CPM.svg">

              <figcaption class="multi-line-pdf"><strong>Figure 25.</strong> The model of <a href="#_Ref494405660">Figure 24</a> with an activity
              replacing the start/end event pair.</figcaption>
            </figure>
          </section>

          <section id="sect7.2.2">
            <h1>Making a Process Design Model</h1>

            <p>In the process design model, we only need to include two event rules, one for <i>CustomerArrival</i> and one for
            <i>CustomerDeparture</i> events, since only these two event types have been included in the information design model in <a href="#_Ref494399721">Figure 21</a>.</p>

            <table class="top">
              <caption><strong>Table 5.</strong> The event rule design table for the service system.</caption>
              <thead>
                <tr>
                  <th>ON (event expr.)</th>

                  <th>DO (event routine)</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td>
                    <p>CustomerArrival( c, sd) @ t</p>

                    <ul style="font-size: smaller">
                      <li>c:Customer references the arrived customer</li>

                      <li>sd:Servicedesk references the service desk where the new customer arrived</li>
                    </ul>
                  </td>

                  <td>
                    <pre>                  <code>
sd.waitingCustomers.<b>enqueue</b>(c)
<b>if</b> sd.waitingCustomers.length = 1 <b>then</b>
  <b>schedule</b> CustomerDeparture( sd) @
   (t + ServiceDesk.serviceDuration())
                  </code>
                </pre>
                  </td>
                </tr>

                <tr>
                  <td>
                    <p>CustomerDeparture( sd) @ t</p>

                    <ul style="font-size: smaller">
                      <li>sd:Servicedesk references the service desk from where the customer departs</li>
                    </ul>
                  </td>

                  <td>
                    <pre>                  <code>
sd.waitingCustomers.<b>dequeue</b>()
<b>if</b> sd.waitingCustomers.length &gt; 0 <b>then</b>
  <b>schedule</b> CustomerDeparture( sd) @
   (t + ServiceDesk.serviceDuration())
                  </code>
                </pre>
                  </td>
                </tr>
              </tbody>
            </table>

            <p>These two event rule design models are visually expressed in the DPMN diagrams shown in <a href="#_Ref499542497">Figure 26</a> and <a href="#_Ref499542498">Figure 27</a>.</p>

            <figure id="_Ref499542497" data-enlarge-by="0.5">
              <img src="./img/Service-Arrival_RDM.svg">

              <figcaption class="multi-line-pdf"><strong>Figure 26.</strong> A DPMN design model for the customer arrival event rule.</figcaption>
            </figure>

            <figure id="_Ref499542498" data-enlarge-by="0.5">
              <img src="./img/Service-Departure_RDM.svg">

              <figcaption class="multi-line-pdf"><strong>Figure 27.</strong> A DPMN design model for the customer departure event rule.</figcaption>
            </figure>

            <p>These two event rule design models can be merged into a process design model shown in <a href="#_Ref499542496">Figure 28</a>.</p>

            <figure class="top" id="_Ref499542496" data-enlarge-by="0.5">
              <img src="./img/Service_PDM.svg" width="550">

              <figcaption><strong>Figure 28.</strong> A DPMN process design model integrating the two rule design models.</figcaption>
            </figure>

            <p>Notice that since <code>sd.waitingCustomers</code> denotes a <em>queue</em>, we use the queue operations <em>ENQUEUE</em> and <em>DEQUEUE</em>
            in the state change statements within the <code>sd:ServiceDesk</code> object rectangle. Generally, in DPMN, state change statements are
            expressed in a state change language that depends on the state structure of the modeled system. Typically, this will be an object-oriented
            system state structure where basic state changes consist of attribute value changes as well as creations and destructions of links between
            objects.</p>
          </section>

          <section id="sect7.2.3">
            <h1>Implementing the Process Design Model with OESjs</h1>

            <p>The event rules specified by the process design model can be implemented with OESjs by coding its event routine in the
            <code>onEvent</code> method of the class that represents the triggering event type. For instance, the <em>CustomerArrival</em> event rule
            modeled in <a href="#_Ref499542497">Figure 26</a> can be coded as follows:</p>

            <pre class="  language-javascript"><code class="  language-javascript"><span class="token keyword">var</span> CustomerArrival <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">cLASS</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  Name<span class="token punctuation">:</span> <span class="token string">"CustomerArrival"</span><span class="token punctuation">,</span>
  supertypeName<span class="token punctuation">:</span> <span class="token string">"eVENT"</span><span class="token punctuation">,</span>
  properties<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"onEvent"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> srvTm<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> followupEvents<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
          sd <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>serviceDesk<span class="token punctuation">;</span>
      <span class="token comment">// create new customer object</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>customer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span>
        <span class="token punctuation">{</span>arrivalTime<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>occTime<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      sim<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>customer<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// enqueue new customer</span>
      sd<span class="token punctuation">.</span>waitingCustomers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>customer<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// if the service desk is not busy</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sd<span class="token punctuation">.</span>waitingCustomers<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        srvTm <span class="token operator">=</span> ServiceDesk<span class="token punctuation">.</span><span class="token function">serviceDuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        followupEvents<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">CustomerDeparture</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          occTime<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>occTime <span class="token operator">+</span> srvTm<span class="token punctuation">,</span>
          serviceDesk<span class="token punctuation">:</span> sd
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> followupEvents<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

            <p>The <em>CustomerDeparture</em> event rule can be coded like so:</p>

            <pre class="  language-javascript"><code class="  language-javascript"><span class="token keyword">var</span> CustomerDeparture <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">cLASS</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  Name<span class="token punctuation">:</span> <span class="token string">"CustomerDeparture"</span><span class="token punctuation">,</span>
  supertypeName<span class="token punctuation">:</span> <span class="token string">"eVENT"</span><span class="token punctuation">,</span>
  properties<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token string">"onEvent"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> srvTm<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> followupEvents<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
          sd <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>serviceDesk<span class="token punctuation">;</span>
      <span class="token comment">// dequeue customer from FIFO queue</span>
      <span class="token keyword">var</span> departingCustomer <span class="token operator">=</span> sd<span class="token punctuation">.</span>waitingCustomers<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// remove customer from simulation</span>
      sim<span class="token punctuation">.</span><span class="token function">removeObject</span><span class="token punctuation">(</span> departingCustomer<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// if there are still customers waiting</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>sd<span class="token punctuation">.</span>waitingCustomers<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// schedule next departure</span>
        srvTm <span class="token operator">=</span> ServiceDesk<span class="token punctuation">.</span><span class="token function">serviceDuration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        followupEvents<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">CustomerDeparture</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          occTime<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>occTime <span class="token operator">+</span> srvTm<span class="token punctuation">,</span>
          serviceDesk<span class="token punctuation">:</span> sd
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> followupEvents<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

            <p>The full code of this simulation model is available by loading the web-based simulation <a href="https://sim4edu.com/sims/2/">https://sim4edu.com/sims/2/</a> and inspecting its JavaScript code in the browser.</p>
          </section>
        </section>
      </section>

      <section id="sect8">
        <h1>Conclusions</h1>

        <p>Combining UML class diagrams with BPMN and DPMN process diagrams allows making visual models for conceptualizing the problem domain of a
        simulation study and for designing a simulation model. The visual simulation design model, consisting of a UML class model and a set of DPMN
        event rule models, represents a computational specification of an abstract state machine that can be directly coded with any OOP language or
        with any OO simulation technology supporting event scheduling.</p>

        <p>Unlike in <em>information systems </em>and<em> software engineering</em>, making visual domain models and design models is not yet an
        established best practice in <em>modeling and simulation</em>. Since these models facilitate the communication, sharing, reuse, maintenance
        and evolution of a simulation model, it can be expected that this will change in the near future.</p>

        <p>After establishing the foundational layer of an OEM approach, based on the concepts of <em>objects</em> and <em>events</em>, we will show
        how the more advanced modeling concepts of <em>activities</em> and GPSS/SIMAN/Arena-style <em>Processing Networks</em> can be defined on the
        basis of objects and events in the second Part of this tutorial. Finally, in Part III, we will further extend the OEM paradigm towards
        agent-based modeling and simulation by adding the concepts of agents with perceptions, actions and beliefs.</p>
      </section>

      <section role="doc-acknowledgements">
       <h1>Acknowledgements</h1>
       <p>The author is grateful to Frederic (Rick) D. McKenzie (†2020) for providing the opportunity to spend a sabbatical at the Modeling, Simulation and Visualization Engineering
        Department of Old Dominion University in Norfolk, Virginia, USA, in 2016. During that time, the grounds of the presented work have been laid.</p>
       <p>This research has <em>not</em> been funded by the German research foundation <em>Deutsche Forschungsgemeinschaft (DFG)</em>.</p>
      </section>

		<section id="sect9" role="doc-bibliography">
        <h1>Bibliography</h1>

        <ul>
          <li id="Ambler2010" role="doc-biblioentry">Ambler, S.W. (2010). <em>UML 2 Class Diagrams</em>. <a href="http://www.agilemodeling.com/artifacts/classDiagram.htm"><img src="../../icons/html.png"></a></li>

          <li id="BankCNN2009" role="doc-biblioentry">Banks, J., Carson, J.S., Nelson, B.L., &amp; Nicol, D.M. (2009). <em>Discrete-Event System
          Simulation</em>. Upper Saddle River, NJ: Prentice Hall.</li>

          <li id="Camunda2017" role="doc-biblioentry">BPMN 2.0 Tutorial. (2017). <em>Camunda</em>. <a href="https://camunda.com/bpmn/"><img src="../../icons/link.png"></a></li>

          <li id="CetinkayaVS2011" role="doc-biblioentry">Cetinkaya, D., Verbraeck, A., &amp; Seck, M. (2011). MDD4MS: A Model Driven Development Framework for Modeling and Simulation. In <em>Proceedings of the 2011 Summer Computer Simulation Conference (SCSC 2011)</em>. The Hague, Netherlands.</li>

          <li id="Cet11" role="doc-biblioentry">Cetinkaya, D., &amp; Verbraeck, A. (2011). Metamodeling and Model Transformations in Modeling and
          Simulation. In <em>Proceedings of the 2011 Winter Simulation Conference</em> (pp. 3048−3058). Piscataway, NJ: IEEE. <a href="http://www.informs-sim.org/wsc11papers/271.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="DahlNygaard66" role="doc-biblioentry">Dahl, O.-J., &amp; Nygaard, K. (1966). Simula – an ALGOL-Based Simulation Language.
          <em>Communications of the ACM</em>. 9(9), 671–678. <a href="https://dx.doi.org/10.1145/365813.365819"><img src="../../icons/doi.png"></a> <a href="http://simula67.at.ifi.uio.no/Archive/artikkel1966cacm.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="Gordon61" role="doc-biblioentry">Gordon, G. (1961). A General Purpose Systems Simulation Program. In <em>Proceedings of the Eastern
          Joint Computer Conference</em>. Washington, D.C.</li>

          <li id="GuizzardiW2010a" role="doc-biblioentry">Guizzardi, G., &amp; Wagner, G. (2010a). Using the Unified Foundational Ontology (UFO) as a
          Foundation for General Conceptual Modeling Languages. In Poli R., Healy M., Kameas A. (eds) <em>Theory and Applications of Ontology:
          Computer Applications</em> (pp. 175–196). Dordrecht: Springer. <a href="https://dx.doi.org/10.1007/978-90-481-8847-5_8"><img src="../../icons/doi.png"></a> <a href="http://www.inf.ufes.br/~gguizzardi/TAO-CR.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="GuizzardiW2010b" role="doc-biblioentry">Guizzardi, G., &amp; Wagner, G. (2010b). Towards an Ontological Foundation of Discrete Event
          Simulation. In <em>Proceedings of the 2010 Winter Simulation Conference</em> (pp. 652–664). Piscataway, NJ: IEEE. <a href="http://www.informs-sim.org/wsc10papers/059.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="GuizzardiW2012" role="doc-biblioentry">Guizzardi, G., &amp; Wagner, G. (2012). Tutorial: Conceptual Simulation Modeling with
          Onto-UML. In <em>Proceedings of the 2012 Winter Simulation Conference</em>. Piscataway, NJ: IEEE. <a href="http://informs-sim.org/wsc12papers/includes/files/inv284.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="GuizzardiW2013" role="doc-biblioentry">Guizzardi, G., &amp; Wagner, G. (2013). Dispositions and Causal Laws as the Ontological
          Foundation of Transition Rules in Simulation Models. In <em>Proceedings of the 2013 Winter Simulation Conference</em> (pp. 1335–1346). Piscataway, NJ: IEEE. <a href="http://informs-sim.org/wsc13papers/includes/files/117.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="Himmelspach2009" role="doc-biblioentry">Himmelspach, J. (2009). Toward a Collection of Principles, Techniques and Elements of
          Modeling and Simulation Software. In <em>Proc. of the 2009 International Conference on Advances in System Simulation</em> (pp. 56–61). IEEEComputer Society. <a href="https://dx.doi.org/10.1109/SIMUL.2009.19"><img src="../../icons/doi.png"></a> <a href="https://www.computer.org/csdl/proceedings/simul/2009/3773/00/3773a056-abs.html"><img src="../../icons/html.png"></a></li>

          <li id="MarkHK62" role="doc-biblioentry">Markowitz, H., Hausner, B., &amp; Karr, H. (1962). <em>SIMSCRIPT: A Simulation Programming
          Language</em>. (Report No. RM-3310-PR). Santa Monica, CA: The RAND Corporation. <a href="https://www.rand.org/content/dam/rand/pubs/research_memoranda/2009/RM3310.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="Ong11" role="doc-biblioentry">Onggo, B., &amp; Karpat, O. (2011). Agent-Based Conceptual Model Representation Using BPMN. In
          <em>Proceedings of the 2011 Winter Simulation Conference</em> (pp. 671–682). Piscataway, NJ: IEEE. <a href="http://www.informs-sim.org/wsc11papers/060.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="Peg92" role="doc-biblioentry">Pegden, C.D., &amp; Davis, D.A. (1992). Arena: a SIMAN/Cinema-Based Hierarchical Modeling System. In
          <em>Proceedings of the 1992 Winter Simulation Conference</em> (pp. 390–399). Piscataway, NJ: IEEE. <a href="http://informs-sim.org/wsc92papers/1992_0050.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="Peg10" role="doc-biblioentry">Pegden, C.D. (2010). Advanced Tutorial: Overview of Simulation World Views. In <em>Proceedings of the 2010 Winter Simulation Conference</em> (pp. 643–651). Piscataway, NJ: IEEE. <a href="http://www.informs-sim.org/wsc10papers/019.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="Rob13" role="doc-biblioentry">Robinson, S. (2013). Conceptual Modeling for Simulation. In <em>Proceedings of the 2013 Winter
          Simulation Conference</em> (pp. 377–388). Piscataway, NJ: IEEE. <a href="http://informs-sim.org/wsc13papers/includes/files/032.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="LSch83" role="doc-biblioentry">Schruben, L. (1983). Simulation Modeling with Event Graphs. <em>Communications of the ACM</em> 26(11), 957–963. <a href="https://dx.doi.org/10.1145/182.358460"><img src="../../icons/doi.png"></a> <a href="https://dl.acm.org/citation.cfm?id=358460"><img src="../../icons/pdf.png"></a></li>

          <li id="Tak10" role="doc-biblioentry">Tako, A.A., Kotiadis, K., &amp; Vasilakis, C. (2010). A Participative Modeling Framework for
          Developing Conceptual Models in Healthcare Simulation Studies. In <em>Proceedings of the 2010 Winter Simulation Conference</em> (pp.
          500–512). Piscataway, NJ: IEEE. <a href="https://dx.doi.org/10.1109/WSC.2010.5679135"><img src="../../icons/doi.png"></a> <a href="http://www.informs-sim.org/wsc10papers/045.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="Wag09" role="doc-biblioentry">Wagner, G., Nicolae, O., &amp; Werner, J. (2009). Extending Discrete Event Simulation by Adding an
          Activity Concept for Business Process Modeling and Simulation. In <em>Proceedings of Winter Simulation Conference</em> (pp. 2951−2962).
          Piscataway, NJ: IEEE. <a href="http://www.informs-sim.org/wsc09papers/286.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="GWa17a" role="doc-biblioentry">Wagner, G. (2017a). An Abstract State Machine Semantics For Discrete Event Simulation. In
          <em>Proceedings of the 2017 Winter Simulation Conference</em>. Piscataway, NJ: IEEE. <a href="https://www.informs-sim.org/wsc17papers/includes/files/056.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="GWa17b" role="doc-biblioentry">Wagner, G. (2017b). Introduction to Information and Process Modeling for Simulation. In
          <em>Proceedings of the 2017 Winter Simulation Conference</em>. Piscataway, NJ: IEEE.</li>

          <li id="GWa17c" role="doc-biblioentry">Wagner, G. (2017c). Sim4edu.com – Web-Based Simulation for Education. In <em>Proceedings of the 2017 Winter Simulation Conference</em>. Piscataway, NJ: IEEE. <a href="https://www.informs-sim.org/wsc17papers/includes/files/360.pdf"><img src="../../icons/pdf.png"></a></li>

          <li id="GWa18" role="doc-biblioentry">Wagner, G. (2018). Discrete Event Process Modeling Notation (DPMN). <a href="https://dpmn.info/spec/"><img src="../../icons/html.png"></a></li>

          <li id="Dur10" role="doc-biblioentry">Zee, D., Kotiadis, K., Tako, A.A., Pidd, M., Balci, O., Tolk, A., &amp; Elder, M. (2010). Panel
          Discussion: Education on Conceptual Modeling for Simulation – Challenging the Art. In <em>Proceedings of the 2010 Winter Simulation
          Conference</em> (pp. 290–304). Piscataway, NJ: IEEE. <a href="http://www.informs-sim.org/wsc10papers/026.pdf"><img src="../../icons/pdf.png"></a></li>
        </ul>
      </section>

  <section id="sect10" class="no-counter">
    <h1>Copyright Information</h1>
    <p prefix="cc: http://creativecommons.org/ns#">
      <a rel="license" href="https://creativecommons.org/licenses/by/4.0/" target="_blank"><img alt="Creative Commons License" src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a> Copyright © 2018 <span property="cc:attributionName">Gerd Wagner</span>. This article is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.
    </p>
  </section>
  </main>

  <nav id="toc" class="suppressInPDF">
    <h1>Outline</h1>
    <ol start="0">
      <li style="list-style: none;"><a href="#sect0">Abstract</a></li>
      <li><a href="#sect1">Introduction</a></li>
      <li><a href="#sect2">What Is Discrete Event Simulation?</a></li>
      <li><a href="#sect3">Model-Driven Engineering</a></li>
      <li><a href="#sect4">Information Modeling with UML Class Diagrams</a></li>
      <li><a href="#sect5">Process Modeling with BPMN and DPMN</a></li>
      <li><a href="#sect6">Example 1: An Inventory System</a></li>
      <li><a href="#sect7">Example 2: A Service System</a></li>
      <li><a href="#sect8">Conclusions</a></li>
      <li style="list-style: none;"><a href="#sect9">Bibliography</a></li>
      <li style="list-style: none;"><a href="#sect10">Copyright Information</a></li>
    </ol>
    <div id="return-top">
      <svg id="arrow-up" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M952.576 554.858667q0 29.141333-21.141333 51.434667l-42.858667 42.858667q-21.717333 21.717333-52.010667 21.717333-30.848 0-51.434667-21.717333l-168-167.424 0 402.282667q0 29.717333-21.418667 48.277333t-51.712 18.581333l-73.152 0q-30.293333 0-51.712-18.581333t-21.418667-48.277333l0-402.282667-168 167.424q-20.565333 21.717333-51.434667 21.717333t-51.434667-21.717333l-42.858667-42.858667q-21.717333-21.717333-21.717333-51.434667 0-30.293333 21.717333-52.010667l372.010667-372.010667q20.010667-21.141333 51.434667-21.141333 30.848 0 52.010667 21.141333l372.010667 372.010667q21.141333 22.293333 21.141333 52.010667z" /></svg><a href="">Return to top</a>
    </div>
    <div id="share">
      <button id="share-this" title="Share this">Share...</button>
      <ul class="links">
        <li class="share facebook" title="Share on Facebook"><svg aria-hidden="true"
               class="icon-social">
            <symbol id="social-facebook" viewBox="0 0 18 18">
              <path
                    d="M15.7,1.5H2.3c-0.5,0-0.8,0.4-0.8,0.8v13.3c0,0.5,0.4,0.8,0.8,0.8h7.2v-5.8h-2V8.4h2V6.8c0-1.9,1.2-3,2.9-3 c0.8,0,1.5,0.1,1.7,0.1v2l-1.2,0c-0.9,0-1.1,0.4-1.1,1.1v1.4h2.2l-0.3,2.3h-1.9v5.8h3.8c0.5,0,0.8-0.4,0.8-0.8V2.3 C16.5,1.9,16.1,1.5,15.7,1.5z">
              </path>
            </symbol>
            <use xmlns:xlink="http://www.w3.org/1999/xlink"
                 xlink:href="#social-facebook" />
          </svg></li>
        <li class="share twitter" title="Share on X"><svg aria-hidden="true"
               class="icon-social">
            <symbol id="social-twitter" viewBox="0 0 18 18">
              <path d="M12.6.75h2.454l-5.36 6.142L16 15.25h-4.937l-3.867-5.07-4.425 5.07H.316l5.733-6.57L0 .75h5.063l3.495 4.633L12.601.75Zm-.86 13.028h1.36L4.323 2.145H2.865z">
              </path>
            </symbol>
            <use xmlns:xlink="http://www.w3.org/1999/xlink"
                 xlink:href="#social-twitter" />
          </svg></li>
        <li class="share linkedin" title="Share on LinkedIn"><svg aria-hidden="true"
               class="icon-social">
            <symbol id="social-linkedin" viewBox="0 0 18 18">
              <path
                    d="M15.4,1.5H2.6C2,1.5,1.5,2,1.5,2.6v12.8c0,0.6,0.5,1.1,1.1,1.1h12.8c0.6,0,1.1-0.5,1.1-1.1V2.6C16.5,2,16,1.5,15.4,1.5z M3.8,7.1H6v7.2H3.8V7.1z M4.9,6.1c-0.7,0-1.3-0.6-1.3-1.3c0-0.7,0.6-1.3,1.3-1.3c0.7,0,1.3,0.6,1.3,1.3C6.2,5.6,5.6,6.1,4.9,6.1z M14.5,14.3h-2.3v-3.5c0-0.8,0-1.9-1.2-1.9c-1.2,0-1.4,0.9-1.4,1.8v3.5H7.4V7.1h2.2v1h0c0.3-0.6,1-1.2,2.1-1.2 c2.3,0,2.7,1.5,2.7,3.4V14.3z">
              </path>
            </symbol>
            <use xmlns:xlink="http://www.w3.org/1999/xlink"
                 xlink:href="#social-linkedin" />
          </svg></li>
        <li class="share email" title="Share with Email"><a
             aria-label="Share with Email" href="" target="_blank"><svg
                 aria-hidden="true" class="icon-social">
              <symbol id="social-mail" viewBox="0 0 18 18">
                <path
                      d="M9,8.2L3,4.5h12L9,8.2z M15,13.5H3V6l6,3.8L15,6V13.5z M15,3H3C2.2,3,1.5,3.7,1.5,4.5l0,9C1.5,14.3,2.2,15,3,15 h12c0.8,0,1.5-0.7,1.5-1.5v-9C16.5,3.7,15.8,3,15,3z">
                </path>
              </symbol>
              <use xmlns:xlink="http://www.w3.org/1999/xlink"
                   xlink:href="#social-mail" />
            </svg></a></li>
      </ul>
    </div>
  </nav>
  <script>
    // load iframe only after loading the page
    document.getElementById("iframe-sim4").src = "https://sim4edu.com/sims/4/"
  </script>
</body>
</html>
